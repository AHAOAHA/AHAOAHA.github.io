<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苦心人，天不負，臥薪嘗膽，三千越甲可吞吳</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ahaoaha.top/"/>
  <updated>2019-09-08T06:53:16.011Z</updated>
  <id>http://ahaoaha.top/</id>
  
  <author>
    <name>AHAOAHA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Questions</title>
    <link href="http://ahaoaha.top/2019/09/08/Questions/"/>
    <id>http://ahaoaha.top/2019/09/08/Questions/</id>
    <published>2019-09-08T04:33:23.000Z</published>
    <updated>2019-09-08T06:53:16.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><ol><li><p>shell脚本文件与命令行执行不一致问题：</p><blockquote><p>问题背景：通过shell命令判断某pid是否在当前机器存在，使用命令<code>ps aux | grep [PID] | grep -v grep | wc -l</code>返回值判断。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x.sh</span></span><br><span class="line"></span><br><span class="line">count=`ps aux | grep $&#123;1&#125; | grep -v grep | wc -l`</span><br><span class="line">echo $count</span><br></pre></td></tr></table></figure><p>问题描述：传入一个不存在的pid，count为2，偶尔为5，看起来像一个随机数。通过bash直接执行<code>ps aux | grep [PID] | grep -v grep | wc -l</code>结果为0。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shell&quot;&gt;&lt;a href=&quot;#shell&quot; class=&quot;headerlink&quot; title=&quot;shell&quot;&gt;&lt;/a&gt;shell&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shell脚本文件与命令行执行不一致问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题背景：通过
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cmake常用命令</title>
    <link href="http://ahaoaha.top/2019/07/28/cmake%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://ahaoaha.top/2019/07/28/cmake%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-07-28T08:33:43.000Z</published>
    <updated>2019-09-08T05:10:57.105Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><ul><li><code>cmake_minimum_required(VERSION xxx)</code>：指明所需要的最低cmake版本为xxx</li><li><code>project([PROJECT_NAME] [CXX][C][Java])</code>：该函数用来定义工程名称，并指定工程支持的语言，支持的语言选项是可以忽略的，默认支持所有语言。</li><li><code>set([VALUE_NAME] [VALIUE])</code>：该函数用来显式的定义变量，[VALUE]是一个可变参数列表。</li><li><code>message(SEND_ERROR|STATUS|FAUAL_ERROR &quot;echo message&quot; ...)</code>：该函数用来向终端输出信息<ul><li>SEND_ERROR：产生错误，生成过程被跳过</li><li>STATUS：输出前缀为–的状态信息</li><li>FATAL_ERROR：立即终止cmake过程</li></ul></li></ul><ul><li><code>add_executable([OUTPPUT_NAME] [SOURCE_LIST])</code>：生成可执行文件<ul><li>[OUTPPUT_NAME]：表示生成的可执行文件名</li><li>[SOURCE_LIST]：表示生成可执行文件依赖的所有文件</li></ul></li><li><code>add_library([LIB_NAME] [SOURCE_LIST])</code>：生成静态库<ul><li>[LIB_NAME]：表示生成的静态库名（不包含静态库lib前缀和.a后缀）</li><li>[SOURCE_LIST]：表示生成静态库依赖的所有文件</li></ul></li><li><code>add_library([SO_NAME] SHARED [SOURCE_LIST])</code>：生成动态库<ul><li>[SO_NAME]：表示生成的动态库名（不包含动态库lib前缀和.so后缀）</li><li>SHARED：指明生成的库类型，生成动态库时应为<code>SHARED</code></li><li>[SOURCE_LIST]：表示生成动态库依赖的所有文件</li></ul></li><li><code>aux_source_directory([DIR] [VAR])</code>：将所有的[DIR]都赋值给[VAR]</li><li><code>add_definitions(&quot;xxx xxx&quot;)</code>：设置编译选项以及参数</li><li><code>include_directories([DIR])</code>：设置第三方库头文件所在路径，使用&lt;&gt;包括的第三方库也会在该路径下寻找</li><li><code>link_directories([DIR])</code>：设置第三方静态/动态库的路径，类似编译选项中的<code>-L</code>选项</li><li><code>target_link_libraries([PROJECT_NAME] [LIB_NAME]...)</code>：设置要链接的第三方库，类似编译选项中的<code>-l</code>选项</li><li><code>aux_source_directory([DIR], [VAR])</code>：将[DIR]目录下的所有的cpp文件以绝对路径的方式赋值给[VAR]</li></ul><h4 id="cmake变量"><a href="#cmake变量" class="headerlink" title="cmake变量"></a>cmake变量</h4><ul><li><code>CMAKE_VERBOSE_MAKEFILE</code> ：表示是否输出详细的编译和链接信息，对应on/off</li><li><code>EXECUTABLE_OUTPUT_PATH</code> ：表示可执行文件的输出目录</li><li><code>LIBRARY_OUTPUT_PATH</code> ：表示链接库的输出目录</li><li><code>CMAKE_CXX_FLAGS</code>：表示编译器的编译参数，后跟””引号内添加编译参数</li><li><code>CMAKE_CXX_COMPILER</code> ：表示使用的编译器，后跟””引号内指明编译器类型</li><li><code>CMAKE_CXX_FLAGS_DEBUG</code> ：debug版本特有的编译选项</li><li><code>CMAKE_CXX_FLAGS_RELEASE</code>：release版本下特有的编译选项</li><li><code>CMAKE_SOURCE_DIR</code>：CMakeLists.txt所在的路径</li></ul><h5 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h5><ul><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：表示当前CMakeLists.txt文件所路径</li><li><code>CMAKE_SOURCE_DIR</code>：表示工程的顶层目录</li><li><code>CMAKE_MODULE_PATH</code>：参见find_package</li></ul><h4 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h4><p>在使用第三方库的情况下，find_package的用来寻找第三方库的.h和.so/.a/文件所在的路径并将找到的路径设置为变量以供CMakeLists.txt的其他部分使用。</p><p>find_package(xxx)会去<code>${CMAKE_MODULE_PATH}</code>的所有路径中去寻找xxx.cmake或config.cmake文件，这两个文件时库文件安装时自己安装的，将自己路径硬编码到其中。前者称为module模式，后者成为config模式。</p><p>xxx.cmake会提供以下变量：</p><ul><li><code>&lt;name&gt;_FOUND</code>：表示是否查到</li><li><code>&lt;name&gt;_INCLUDE_DIR</code>或<code>&lt;name&gt;_INCLUDES</code>：表示头文件的位置</li><li><code>&lt;name&gt;_LIBRARY</code>或<code>&lt;name&gt;_LIBRARIES</code>或<code>&lt;name&gt;_LIBS</code>：表示库文件路径和名称</li><li><code>&lt;name&gt;_DEFINITIONS</code></li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>在cmake中使用include(&lt;arg1&gt;)时，cmake会搜索系统安装的目录，也会搜索<code>CMAKE_MODULE_PATH</code>指定的目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;内建函数&quot;&gt;&lt;a href=&quot;#内建函数&quot; class=&quot;headerlink&quot; title=&quot;内建函数&quot;&gt;&lt;/a&gt;内建函数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmake_minimum_required(VERSION xxx)&lt;/code&gt;：指明所需要的最
      
    
    </summary>
    
    
    
      <category term="cmake" scheme="http://ahaoaha.top/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Notes</title>
    <link href="http://ahaoaha.top/2019/05/15/Nginx-Notes/"/>
    <id>http://ahaoaha.top/2019/05/15/Nginx-Notes/</id>
    <published>2019-05-15T13:55:20.000Z</published>
    <updated>2019-09-08T05:10:57.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h3><p>Nginx是一款由俄罗斯程序员lgor Sysoev所开发的高性能<strong>Web和反向代理服务器</strong>，也是一个IMAP/POP3/SMTP代理服务器。本文仅涉及Web和反向代理服务器的领域。</p><h4 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h4><p><strong>通常一个大型项目会部署在一组或者多组的后端服务器上，反向代理即就是做这些后端服务器的代理人，只把代理人的IP/域名暴露给客户端，当客户端请求到达时，代理人根据客户端的请求，从其后端的服务器上获取资源，再返回给客户端，从客户端角度来看，只能感知到代理人的存在，而不会感知到后台服务器的存在</strong>。</p><h3 id="Nginx的特点"><a href="#Nginx的特点" class="headerlink" title="Nginx的特点"></a>Nginx的特点</h3><ul><li><strong>反向代理加速（无缓存）</strong></li><li><strong>简单的负载均衡和容错</strong></li><li><strong>基于IP和名称的虚拟主机服务</strong></li><li><strong>支持keep-alive和管道连接</strong></li><li><strong>支持热重启</strong></li><li>…</li></ul><h3 id="Nginx内置负载均衡相关策略"><a href="#Nginx内置负载均衡相关策略" class="headerlink" title="Nginx内置负载均衡相关策略"></a>Nginx内置负载均衡相关策略</h3><ul><li><p><strong>基于轮询的均衡策略</strong></p><blockquote><p><strong>轮询策略时Nginx的默认负载均衡策略，就是对于到达Nginx服务器的请求按照遍历的方式进行发放</strong></p></blockquote></li><li><p><strong>基于最少连接数的均衡策略</strong></p><blockquote><p><strong>在该策略下，Nginx会判断当前后端集群服务器中哪个server的Active Connection的数量是最少的，对于新到达Nginx服务器的请求，Nginx将转发给对应的后端服务器</strong></p></blockquote></li><li><p><strong>基于IP-hash的均衡策略</strong></p><blockquote><p><strong>使用请求的IP地址建立IP-Server之间的映射关系，将对应的IP转发给对应的Server</strong></p></blockquote></li><li><p><strong>基于加权轮询的衡策略</strong></p><blockquote><p><strong>根据Server的各项信息组织Server的权重，按照优先级进行排序，将请求发给当前优先级最高的Server</strong></p></blockquote></li></ul><h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><p><code>yum install nginx</code></p><h3 id="Nginx结构"><a href="#Nginx结构" class="headerlink" title="Nginx结构"></a>Nginx结构</h3><h4 id="Nginx-master进程"><a href="#Nginx-master进程" class="headerlink" title="Nginx master进程"></a>Nginx master进程</h4><p><em>主要用来管理worker进程，同时接收来自外界的信号，像各个worker进程发送信号，监控worker进程的运行状态（当worker异常退出时，会重启worker进程）</em></p><ul><li><strong>读取和验证配置</strong></li><li><strong>创建，绑定，关闭socket</strong></li><li><strong>启动，终止，维护worker进程的配置数量</strong></li><li><strong>热重启</strong></li><li><strong>控制非停止的二进制更新</strong></li><li><strong>重新打开日志文件</strong></li><li><strong>编译嵌入的Perl脚本</strong></li></ul><h4 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h4><p><em>处理网络事件请求，多个worker进程之间同等竞争来自客户端的请求，相互独立；一个请求只可能在一个worker进程中被处理，当请求到达时，所有的worker进程争抢锁accept_mutex，抢到锁的进程处理当前请求</em></p><ul><li><strong>接收，处理来自客户端的连接</strong></li><li><strong>提供反向代理和过滤功能</strong></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于<code>/etc/nginx/nginx.conf</code>，<code>nginx -t</code>检测当前配置文件是否有语法错误，<code>nginx -s reload</code>不影响nginx服务器并且令当前配置文件生效。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局模块</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#events模块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#http全局模块</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment">#server全局模块</span></span><br><span class="line">    <span class="attribute">location</span> [svr] &#123;</span><br><span class="line">        <span class="comment">#location模块</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a>全局模块</h4><p><strong>该模块配置影响Nginx的全局指令，通常有运行nginx的用户，允许生成worker的进程数，日志存放路径，nginx进程pid存放路径等信息，配置文件引入</strong></p><h4 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h4><p><strong>该模块配置影响nginx服务器与用户的网络连接，通常有每个进程的最大连接数</strong></p><h4 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h4><p><strong>可以嵌套多个server，配置代理、缓存、日志定义等绝大多数功能和第三方模块配置</strong></p><h4 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h4><p><strong>配置虚拟主机的相关参数，一个http中可以有多个server</strong></p><h4 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h4><p><strong>配置请求的路由，以及各种页面的处理情况</strong></p><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><p>location后面的url使用正则匹配，并遵循一定的优先级</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = [请求内容] &#123;</span><br><span class="line">    <span class="comment"># 只有当请求内容完全匹配时，才能进入这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ [请求内容]</span> &#123;</span><br><span class="line">    <span class="comment"># 不忽略大小写匹配请求内容，匹配成功时进入这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* [请求内容]</span> &#123;</span><br><span class="line">    <span class="comment"># 忽略大小写匹配请求内容，匹配成功时进入这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> [请求内容] &#123;</span><br><span class="line">    <span class="comment"># # 匹配任何以 [请求内容] 开头的请求，匹配符合之后，停止向下搜索正则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.([请求内容1]|[请求内容2])$</span> &#123;</span><br><span class="line">    <span class="comment"># 匹配所有以[请求内容1]或[请求内容2]结尾的请求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="comment"># 匹配所有以/开始的请求，如果以上规则都未匹配，则匹配该规则，类似与default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优先级：= &gt; [完整路径] &gt; ^~ &gt; ~* &gt; 部分起始地址 &gt; /</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> [请求内容] &#123;</span><br><span class="line">    <span class="attribute">root</span> /home/ahao/nginx/;<span class="comment"># 当匹配到这里时，将文件的根目录改变为/home/ahao/nginx/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> [请求内容] &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> [服务器内容路径];<span class="comment"># 当匹配到这里时，检测[请求内容]是否存在，使用第一个被找到的文件返回，如果没有文件被找到，那么将会重定向到[服务器内容路径]</span></span><br><span class="line">    <span class="comment">#$uri代表不带请求参数的当前url</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> [请求内容] &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> [规则] [定向路径] [重写类型];<span class="comment">#需要结合正则表达式，重定向至当前服务器其他目录</span></span><br><span class="line">        <span class="comment">#TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#规则：字符串或正则表达式</span></span><br><span class="line"><span class="comment">#定向路径</span></span><br><span class="line"><span class="comment">#重写类型</span></span><br><span class="line"><span class="comment"># last:表示完成rewrite,浏览器里的url地址不变，last不终止重定向后的url匹配</span></span><br><span class="line"><span class="comment"># break:表示本条规则匹配完成后，终止匹配，不再匹配后面的规则，浏览器里的url变，break终止url匹配</span></span><br><span class="line"><span class="comment"># redirect:返回302临时重定向，浏览器地址会显示跳转后的url地址</span></span><br><span class="line"><span class="comment"># permanent:返回301永久重定向，浏览器地址栏会显示跳转后的url地址</span></span><br></pre></td></tr></table></figure><h4 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置的条件判断</span></span><br><span class="line">-f !-f用来判断是否存在文件</span><br><span class="line">-d !-d用来判断是否存在目录</span><br><span class="line">-e !-e用来判断是否存在文件或目录</span><br><span class="line">-x !-x用来判断文件是否可执行</span><br></pre></td></tr></table></figure><h4 id="内置的全局变量"><a href="#内置的全局变量" class="headerlink" title="内置的全局变量"></a>内置的全局变量</h4><table><thead><tr><th align="center">变量</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">$args</td><td align="center">表示url请求行中的参数，同$query_string</td></tr><tr><td align="center">$content_length</td><td align="center">表示请求头中的Content-length字段</td></tr><tr><td align="center">$content_type</td><td align="center">表示请求头中的Content-Type字段</td></tr><tr><td align="center">$document_root</td><td align="center">表示当前请求在root指令中指定的值</td></tr><tr><td align="center">$host</td><td align="center">表示请求主机头字段，否则则为服务器名称</td></tr><tr><td align="center">$http_user_agent</td><td align="center">表示客户端agent的信息</td></tr><tr><td align="center">$http_cookie</td><td align="center">表示客户端的cookie信息</td></tr><tr><td align="center">$limit_rate</td><td align="center">该变量可以限制连接速率</td></tr><tr><td align="center">$request_method</td><td align="center">表示客户端的请求方法</td></tr><tr><td align="center">$remote_addr</td><td align="center">表示客户端的IP地址</td></tr><tr><td align="center">$remote_port</td><td align="center">表示客户端的端口</td></tr><tr><td align="center">$remote_user</td><td align="center">表示已经经过Auth Basic Module验证的用户名</td></tr><tr><td align="center">$request_filename</td><td align="center">表示当前请求的文件路径，由root或alias指令与url生成</td></tr><tr><td align="center">$scheme</td><td align="center">HTTP方法（HTTP/HTTPS）</td></tr><tr><td align="center">$server_protocol</td><td align="center">表示请求所使用的协议（HTTP/1.0、HTTP/1.1）</td></tr><tr><td align="center">$server_addr</td><td align="center">表示服务器地址，在完成一次系统调用后可以确定这个值</td></tr><tr><td align="center">$server_name</td><td align="center">表示服务器名称</td></tr><tr><td align="center">$server_port</td><td align="center">请求到达服务器的端口号</td></tr><tr><td align="center">$request_uri</td><td align="center">包含请求参数的原始url，不包含主机名（IP地址）</td></tr><tr><td align="center">$uri</td><td align="center">表示不带请求参数和主机名的当前url</td></tr><tr><td align="center">$document_uri</td><td align="center">与uri相同</td></tr></tbody></table><h3 id="内置的负载均衡策略"><a href="#内置的负载均衡策略" class="headerlink" title="内置的负载均衡策略"></a>内置的负载均衡策略</h3><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><blockquote><p>轮询策略即就时按照后台server的顺序，当请求到达时，依次发放请求让server去处理请求使得后台服务器之间的负载相对均衡，但是这种方式在后台服务器的状态基本一致时是最有效的，但是机器的状态是随着服务时间而发生变化的，所以会出现机器负载不均衡的情况，当某一台机器出现问题时，也无法将出现问题的机器边缘化。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置方法</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> mySevers &#123;</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://mySevers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h4><blockquote><p>为后台server的每一台机器根据其状态添加权重，按照权重的优先级来分配到达的请求。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置方法</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> mySevers &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">         <span class="attribute">proxy_pass</span> http://myServers;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IP-hash映射"><a href="#IP-hash映射" class="headerlink" title="IP-hash映射"></a>IP-hash映射</h4><blockquote><p>IP-hash映射的方法可以解决session在后台服务器之间不共享的问题，来自同一个IP的请求会一直被分配到同一台后台服务器上。根据客户端IP计算得到一个数值，对应的后端机器处理某一个特定的值。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置方法</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> mySevers &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">         <span class="attribute">proxy_pass</span> http://myServers;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h4><blockquote><p>根据各个服务器当前连接状况分配请求。least_conn算法首先会遍历后端集群，比较每个后端的连接数，选取值最小的机器，如果多个后端的连接数同为最小的，则对它们采用加权轮询算法。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置方法</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> mySevers &#123;</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT] weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> [DNS/IP]+[PORT] weight=<span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">         <span class="attribute">proxy_pass</span> http://myServers;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Nginx&quot;&gt;&lt;a href=&quot;#什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是Nginx&quot;&gt;&lt;/a&gt;什么是Nginx&lt;/h3&gt;&lt;p&gt;Nginx是一款由俄罗斯程序员lgor Sysoev所开发的高性能&lt;strong&gt;Web和反
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://ahaoaha.top/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang中协程的使用</title>
    <link href="http://ahaoaha.top/2019/05/09/Golang%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ahaoaha.top/2019/05/09/Golang%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-05-09T03:03:20.000Z</published>
    <updated>2019-09-08T05:10:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>GoRoutine</p><a id="more"></a><p>本文相关demo，请<a href="https://github.com/AHAOAHA/GoCode/tree/master/linux_go/src/code" target="_blank" rel="noopener">点击此处</a></p><h3 id="协程与函数返回值"><a href="#协程与函数返回值" class="headerlink" title="协程与函数返回值"></a>协程与函数返回值</h3><p>golang中的协程是由Go routime进行管理的，如果函数有返回值，则这个函数的返回值会被丢弃。</p><h3 id="Golang协程的创建"><a href="#Golang协程的创建" class="headerlink" title="Golang协程的创建"></a>Golang协程的创建</h3><p><strong>使用<code>go FUNC_NAME(PARAMETER_LIIST)</code>可以很简单的创建出一个协程来执行相应的操作</strong></p><h3 id="Golang协程的管理"><a href="#Golang协程的管理" class="headerlink" title="Golang协程的管理"></a>Golang协程的管理</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h5 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h5><p><strong>用来设置计数器等待线程完成之后再继续进行主执行流</strong></p><ul><li><strong><code>func (wg *WaitGroup) Add(delta int)</code>：设置一个计数器，delta表明该计数器用来管理的协程的数量，计数器的设置应该位于主执行流中</strong></li><li><strong><code>func (wg *WaitGroup) Done()</code>：对计数器进行–操作，该操作应该位于协程自身的执行流的末尾</strong></li><li><strong><code>func (wg *WaitGroup) Wait()</code>：等待计数器所管理的协程的执行完毕，也就是在等待计数器的值变为0，如果计数器的值不为0，则主执行流会阻塞在此处</strong></li></ul><p><em>计数器变为负数的情况：会在运行时panic，panic的位置发生在sync包</em></p><h5 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h5><p><strong>用来控制函数只能被调用一次</strong></p><ul><li><strong><code>func (o *Once) Do(f func())</code>：保证f函数只被执行一次</strong></li></ul><p><em>可以看出，f函数通常是一个没有参数和返回值的函数</em></p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once Struct &#123;</span><br><span class="line">    m Mutex<span class="comment">//互斥锁</span></span><br><span class="line">    done <span class="keyword">uint32</span><span class="comment">//作为标记位，当函数被执行过一次之后，该数字会被置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123;<span class="comment">//done为1,说明Do函数已经被调用过</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)<span class="comment">//当该作用域声明周期到达时将done设置为1</span></span><br><span class="line">        f()<span class="comment">//执行func函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h5><p><strong>用来使程序更加高效，减少高并发情况下GC过载导致的效率问题</strong></p><ul><li><strong><code>func (p *Pool) Get() interface{}</code>：返回Pool中任意一个对象，如果Pool为空，则New一个新创建的对象</strong></li><li><strong><code>func (p Pool) Put(x interface{})</code>：将对象放入Pool中</strong></li><li><strong>在创建sync.Pool对象时，需要初始化New()函数，作用是当Pool中没有临时对象时，应该返回一个什么样的对象</strong></li></ul><p><em>放入Pool中的对象，会在不一定的时间被清除掉，清理过程是在每次垃圾回收之前做的，垃圾回收是固定两分钟触发一次</em></p><h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><p><strong>协程之间用来通信的类型，可以看作一个管道</strong></p><ul><li><strong>channel必须先创建才能使用，创建channel要使用内建函数make</strong></li><li><strong>使用channel进行协程间同步是使用了channel未接收到数据时阻塞的特性</strong></li></ul><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><h5 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h5><p><strong>普通的互斥锁</strong></p><ul><li><strong><code>func (m *Mutex) Lock()</code>：上锁</strong></li><li><strong><code>func (m *Mutex) Unlock()</code>：解锁</strong></li></ul><h5 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h5><p><strong>读写锁</strong></p><ul><li><strong><code>func (rw *RWMutex) Lock()</code>：写方式加锁</strong></li><li><strong><code>func (rw *RWMutex) Unlock()</code>：写方式解锁</strong></li><li><strong><code>func (rw *RWMutex) RLock()</code>：读方式加锁</strong></li><li><strong><code>func (rw *RWMutex) RUnlock()</code>：读方式解锁</strong></li><li><strong><code>func (rw *RWMutex) RLocker() Locker</code>：返回一个Locker接口，通过rw.RLock和rw.Unlock实现Lock和Unlock方法，个人认为这样做只是为了让代码看起来简介，实质就是以读方式加锁或解锁</strong></li></ul><hr><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><em>golang的Context在golang1.7版本引入标准库</em></p><p><strong>使用golang开发服务器时，通常处理一个请求都是在一个单独的协程中进行的，处理一个请求可能会需要多个协程之间的交互，Context可以使开发者方便协程之间的信息/信号的传递</strong>。</p><h4 id="创建Context对象"><a href="#创建Context对象" class="headerlink" title="创建Context对象"></a>创建Context对象</h4><blockquote><p><strong><code>func Background()</code>：该接口会返回一个空的context对象，通常由该接口来产生根context，通常会搭配<code>WithCancel</code>或<code>WithTimeout</code>或<code>WithDeadline</code>使用</strong></p></blockquote><ul><li><strong><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code>：该接口的作用是产生一个新的ctx与cancel函数，当调用cancel函数时，该ctx会被取消</strong></li><li><strong><code>func WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)</code>：该接口的作用是产生一个新的ctx与cancel函数，当调用cancel函数或者ctx存在时间超过<code>超时时长</code>时该ctx会被取消</strong></li><li><strong><code>func WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc)</code>：该接口的作用是产生一个新的ctx与cancel函数，当调用cancel函数或者到达<code>超时时间</code>时该ctx会被取消</strong></li><li><strong><code>func WithValue(parent Context, key, value interface{})</code>：WithValue函数与取消ctx无关，它是为了生成一个绑定了一个键值对数据的ctx，该数据可以通过ctx.Value()访问到，通过ctx来传递数据</strong></li></ul><h4 id="context-Context接口的方法"><a href="#context-Context接口的方法" class="headerlink" title="context.Context接口的方法"></a>context.Context接口的方法</h4><ul><li><strong><code>[ctx对象].Done() &lt;-chan struct{}</code>：用来判断当前的ctx是否已经被取消</strong></li><li><strong><code>Deadline() (deadline time.Time, ok bool)</code>：用来判断当前ctx对象是否设置超时时间</strong></li><li><strong><code>Err() error</code>：返回当前ctx的error</strong></li><li><strong><code>Value(key interface{}) interface{}</code>：获取绑定在ctx上的键值对，仅有通过WithValue创建与键值对绑定的ctx时才有意义</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GoRoutine&lt;/p&gt;
    
    </summary>
    
    
      <category term="协程" scheme="http://ahaoaha.top/categories/%E5%8D%8F%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang中操作字符串</title>
    <link href="http://ahaoaha.top/2019/04/29/Golang%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://ahaoaha.top/2019/04/29/Golang%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2019-04-29T11:08:34.000Z</published>
    <updated>2019-09-08T05:10:57.100Z</updated>
    
    <content type="html"><![CDATA[<p>golang中使用strings包完成对字符串的主要操作。</p><a id="more"></a><h4 id="判断前缀-后缀"><a href="#判断前缀-后缀" class="headerlink" title="判断前缀/后缀"></a>判断前缀/后缀</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span><span class="comment">//判断字符串s是否以字符串prefix作为开头，返回值为bool</span></span><br><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span><span class="comment">//判断字符串s是否以字符串suffix作为结尾，返回值为bool</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断s字符串是否以prefix作为开头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> || <span class="built_in">len</span>(prefix) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(prefix) &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> prefix &#123;</span><br><span class="line"><span class="keyword">if</span> s[k] != prefix[k] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="keyword">string</span>)</span><span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runes := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> begin, end := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>; begin &lt; end ;begin, end = begin + <span class="number">1</span>, end - <span class="number">1</span> &#123;</span><br><span class="line">runes[begin], runes[end] = runes[end], runes[begin]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(runes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一个包中的public函数可以互相调用，不需要加上包名，也不需要import当前包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> || <span class="built_in">len</span>(suffix) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> restr <span class="keyword">string</span> = reverse(s)</span><br><span class="line"><span class="keyword">var</span> resuffix <span class="keyword">string</span> = reverse(suffix)</span><br><span class="line"><span class="keyword">return</span> MyHasPrefix(restr, resuffix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断子字符串"><a href="#判断子字符串" class="headerlink" title="判断子字符串"></a>判断子字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span><span class="comment">//判断substr是否为s的子字符串</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串的包含关系，判断substr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyContains</span><span class="params">(s, substr <span class="keyword">string</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> || <span class="built_in">len</span>(substr) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i:= MyIndex(s, substr); i == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断子字符串或字符在父字符串中出现的位置"><a href="#判断子字符串或字符在父字符串中出现的位置" class="headerlink" title="判断子字符串或字符在父字符串中出现的位置"></a>判断子字符串或字符在父字符串中出现的位置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span><span class="comment">//返回str在s中第一次出现的位置，若找到，返回值为开始位置的下标；若未找到，返回值为-1</span></span><br><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span><span class="comment">//返回str在s中最后一次出现的位置</span></span><br><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回str中第一个匹配s的首字符的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyIndex</span><span class="params">(s, str <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//s&amp;str都不能为空</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> || <span class="built_in">len</span>(str) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> startpos <span class="keyword">int</span><span class="comment">//在s字符串中起始的比较位置</span></span><br><span class="line"><span class="keyword">var</span> compos <span class="keyword">int</span><span class="comment">//s字符串中，开始与str比较的位置</span></span><br><span class="line"><span class="keyword">var</span> strpos <span class="keyword">int</span><span class="comment">//表示str对应位置</span></span><br><span class="line"><span class="keyword">for</span> startpos = <span class="number">0</span>;startpos &lt; <span class="built_in">len</span>(s);startpos++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[startpos] == str[<span class="number">0</span>] &#123;<span class="comment">//找到第一个匹配字符，保存该位置，开始向后比较</span></span><br><span class="line">compos = startpos</span><br><span class="line">strpos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始比较s&amp;str</span></span><br><span class="line"><span class="keyword">for</span> ;strpos &lt; <span class="built_in">len</span>(str); compos, strpos = compos + <span class="number">1</span>, strpos + <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> compos &gt;= <span class="built_in">len</span>(s) &#123;<span class="comment">//判断compos是否越界，越界说明无匹配字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s[compos] != str[strpos] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> strpos == <span class="built_in">len</span>(str)  &#123;<span class="comment">//匹配字符串完成</span></span><br><span class="line"><span class="keyword">return</span> startpos</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyLastIndex</span><span class="params">(s, str <span class="keyword">string</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> || <span class="built_in">len</span>(str) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">string</span> = reverse(s)</span><br><span class="line"><span class="keyword">var</span> restr <span class="keyword">string</span> = reverse(str)</span><br><span class="line"><span class="keyword">var</span> pos <span class="keyword">int</span> = MyIndex(res, restr)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s) - pos - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>) <span class="keyword">string</span><span class="comment">//将str中前n个字符中的old替换为new，并返回一个新的字符串，如果n = -1则替换所有字符串old为字符串new</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(s, str <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;<span class="comment">//从s的n位置开始，匹配字符串，返回字符串位置</span></span><br><span class="line">runes := []<span class="keyword">rune</span>(s)<span class="comment">//将字符串转换成rune类型的切片</span></span><br><span class="line">runes = runes[n:]<span class="comment">//将切片从n的位置进行切片</span></span><br><span class="line"><span class="keyword">return</span> MyIndex(<span class="keyword">string</span>(runes), str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串中前n个字符中匹配old的字符串替换为new字符串，并返回一个新字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyReplace</span><span class="params">(str, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> str == <span class="string">""</span> || old == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"str || old null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">-1</span> &#123;</span><br><span class="line">n = <span class="built_in">len</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newstr <span class="keyword">string</span><span class="comment">//保存返回的字符串</span></span><br><span class="line"><span class="keyword">var</span> nowpos <span class="keyword">int</span><span class="comment">//标记实时位置</span></span><br><span class="line"><span class="keyword">var</span> modpos <span class="keyword">int</span><span class="comment">//标记修改位置</span></span><br><span class="line"><span class="keyword">var</span> poscount <span class="keyword">int</span></span><br><span class="line">runes := []<span class="keyword">rune</span>(str)<span class="comment">//将原来的字符串进行切片</span></span><br><span class="line"><span class="keyword">for</span> nowpos = <span class="number">0</span>; nowpos &lt; n; nowpos = modpos + <span class="built_in">len</span>(old) &#123;</span><br><span class="line">poscount = modpos</span><br><span class="line">modpos = index(str, old, nowpos)</span><br><span class="line"><span class="keyword">if</span> modpos == <span class="number">-1</span> &#123;<span class="comment">//未匹配到old字符串</span></span><br><span class="line"><span class="keyword">var</span> tmpstr <span class="keyword">string</span> = <span class="keyword">string</span>(runes[nowpos:])</span><br><span class="line">newstr = newstr + tmpstr</span><br><span class="line"><span class="keyword">return</span> newstr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modpos = modpos + nowpos</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmpstr <span class="keyword">string</span> = <span class="keyword">string</span>(runes[nowpos:modpos])</span><br><span class="line">newstr = newstr + tmpstr<span class="comment">//将修改位置的前一部分添加进newstr</span></span><br><span class="line">newstr = newstr + <span class="built_in">new</span><span class="comment">//将new添加进newstr</span></span><br><span class="line">poscount = modpos - poscount</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Repeat(s <span class="keyword">string</span>, count <span class="keyword">int</span>) <span class="keyword">string</span><span class="comment">//重复count次字符串s并返回一个新字符串</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MyStrings</span><br><span class="line"></span><br><span class="line"><span class="comment">//将string字符串重复count次并组织成一个新的字符串返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyRepeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newstr <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">newstr = newstr + s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改大小写"><a href="#修改大小写" class="headerlink" title="修改大小写"></a>修改大小写</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings.ToLower(s) <span class="keyword">string</span><span class="comment">//将字符串s转换为小写</span></span><br><span class="line"><span class="keyword">string</span>.ToUpper(s) <span class="keyword">string</span><span class="comment">//将字符串s转换为大写</span></span><br></pre></td></tr></table></figure><h4 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h4><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings.Fields(s)<span class="comment">//按空格将字符串分割，返回值为一个slice</span></span><br><span class="line">strings.Split(s, sep)<span class="comment">//按sep将字符串分割，返回一个slice</span></span><br></pre></td></tr></table></figure><h4 id="拼接slice到字符串"><a href="#拼接slice到字符串" class="headerlink" title="拼接slice到字符串"></a>拼接slice到字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Join(s1 []<span class="keyword">string</span>, sep <span class="keyword">string</span>) <span class="keyword">string</span><span class="comment">//将元素类型为string的slice使用sep作为分隔符拼接成一个字符串</span></span><br></pre></td></tr></table></figure><h4 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.NewReader(str)<span class="comment">//生成一个Reader并读取字符串内容，返回值为指向该Reader的指针</span></span><br></pre></td></tr></table></figure><hr><h4 id="字符串相关类型转换"><a href="#字符串相关类型转换" class="headerlink" title="字符串相关类型转换"></a>字符串相关类型转换</h4><blockquote><p>字符串与相关类型的转换都是通过strconv包实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.IntSize() <span class="keyword">int</span><span class="comment">//获取程序运行平台下int所占的位数</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Itoa(i <span class="keyword">int</span>) <span class="keyword">string</span><span class="comment">//返回数字i对应的字符串表示</span></span><br></pre></td></tr></table></figure><h5 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi(s <span class="keyword">string</span>) (i <span class="keyword">int</span>, err error)<span class="comment">//将字符串转换为int类型</span></span><br></pre></td></tr></table></figure><h5 id="字符串转float64型数字"><a href="#字符串转float64型数字" class="headerlink" title="字符串转float64型数字"></a>字符串转float64型数字</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.ParseFloat(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>) (f <span class="keyword">float64</span>, err error)<span class="comment">//将字符串转换为float64型</span></span><br></pre></td></tr></table></figure><h5 id="float64型数字转字符串"><a href="#float64型数字转字符串" class="headerlink" title="float64型数字转字符串"></a>float64型数字转字符串</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strconv.FormatFloat(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec <span class="keyword">int</span>, bitSize <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line"><span class="comment">//fmt的取值为'b','e','f','g'</span></span><br><span class="line"><span class="comment">//prec表示精度</span></span><br><span class="line"><span class="comment">//bitSize使用32则表示float32,用64表示float64</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang中使用strings包完成对字符串的主要操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang中的定时任务</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.100Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>设置定时器，经过duration时间，Timer会被触发，Timer被触发之后，调用Reset函数，重新设置定时器，再经过duration的时间，Timer会被再次触发。</p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><ul><li>通过<code>AfterFunc</code>返回Timer对象，<code>AfterFunc</code>被调用之后，再计时结束之后，对应的函数只会被调用一次，如果想让计时器重新生效，则需要通过对象调用<code>Reset</code>。</li><li>通过<code>NewTimer</code>可以创建出Timer对象。</li></ul><h4 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h4><p>设置周期定时器，每间隔duration时间，会将当前的时间发送到chan中，读端可以从chan中读取到到当前的时间。</p><h5 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h5><ul><li>通过<code>NewTicker</code>可以创建Ticker对象，通过对象调用<code>Stop</code>方法可以停止当前Ticker对象运行，但是并不会关闭chan。</li></ul><h3 id="Timer和Ticker的区别"><a href="#Timer和Ticker的区别" class="headerlink" title="Timer和Ticker的区别"></a>Timer和Ticker的区别</h3><ol><li>Ticker完成定义，从当前时刻开始计时，每个固定时间都会被触发；Timer定时器只会被触发一次</li><li>Ticker在不使用时，应该手动Stop，如果不Stop可能会造成资源的泄露，Ticker在触发之后不会自动的从系统中删除；Timer触发之后Timer本身会从时间堆中删除</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Timer&quot;&gt;&lt;a href=&quot;#Timer&quot; class=&quot;headerlink&quot; title=&quot;Timer&quot;&gt;&lt;/a&gt;Timer&lt;/h4&gt;&lt;p&gt;设置定时器，经过duration时间，Timer会被触发，Timer被触发之后，调用Reset函数，重新设置定时器，
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux工具</title>
    <link href="http://ahaoaha.top/2019/04/28/Linux%E5%B7%A5%E5%85%B7/"/>
    <id>http://ahaoaha.top/2019/04/28/Linux%E5%B7%A5%E5%85%B7/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.102Z</updated>
    
    <content type="html"><![CDATA[<p>开一篇博客记录一下平时在linux环境使用到的工具，防止时间太久不使用之后被忘记。</p><h4 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h4><ul><li><strong>符号 ``</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[location ~]$ ssh &#96;cat [ip文件名]&#96;</span><br></pre></td></tr></table></figure><ul><li><strong>$()</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[location ~]$ ssh $(cat [ip文件名])</span><br></pre></td></tr></table></figure><p>这样就可以完成一键完成通过文件中保存的ip连接目标机器了</p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote><p>通过curl可以在Linux环境获取HTTP请求的内容，作用十分相当于windows下的fiddler。</p></blockquote><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><blockquote><p>tail可以对文件进行读取，默认读取文件的最后10行，通常可以用来监视日志文件。</p></blockquote><ul><li><strong>最常用：-f [FILE_NAME]：循环读取文件，首次读取默认读取文件的后10行</strong>。</li></ul><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><blockquote><p>tcpdump是linux环境下的抓包工具，可以用抓取IP\TCP\UDP的数据包。</p></blockquote><ul><li><strong><code>tcpdump -i　[网卡名]</code></strong>：抓取当前机器某网卡上的所有包</li><li><strong><code>tcpdump  ip -i [网卡名]</code></strong>：抓取某网卡上的所有IP包</li><li><strong><code>tcpdump  udp -i [网卡名]</code></strong>：抓取某网卡上的所有UDP包</li><li><strong><code>tcpdump  tcp -i [网卡名]</code></strong>：抓取某网卡上的所有tcp包</li><li><strong><code>tcpdump  tcp -i [网卡名] -X</code></strong>：抓取某网卡上的所有tcp包并打印包内容</li></ul><h4 id="修改用户名和用户组名"><a href="#修改用户名和用户组名" class="headerlink" title="修改用户名和用户组名"></a>修改用户名和用户组名</h4><p>修改用户名需要在root权限下进行：</p><p>修改用户名：<code>usermod -l [新用户名] -d [用户主目录绝对路径] -m [旧用户名]</code></p><p>修改用户组名：<code>groupmod -n [新用户组名] [旧用户组名]</code></p><h3 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h3><p>将一个用户添加进用户组：<code>usermod -a -G [GROUPNAME] [USERNAME]</code></p><p>用户想使用用户组权限时，需要切换当前使用的用户组：<code>newgrp [GROUPNAME]</code></p><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><ul><li>查找文件并删除之：<code>find [PATH] -name [FILE_NAME] -exec rm -rf {} \</code></li></ul><h3 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h3><ul><li>固定时间间隔执行某命令。</li><li><code>-n + [seconds]</code>：固定时间间隔为seconds秒，默认为2秒。</li><li><code>-d</code>：高亮显示发生变化的区域。</li><li><code>-t</code>：不显示头部信息。</li></ul><h3 id="查看网络io状态"><a href="#查看网络io状态" class="headerlink" title="查看网络io状态"></a>查看网络io状态</h3><ul><li><code>iftop</code></li><li><code>watch + netstat</code></li></ul><h3 id="查看磁盘io状态"><a href="#查看磁盘io状态" class="headerlink" title="查看磁盘io状态"></a>查看磁盘io状态</h3><ul><li><code>iotop</code></li><li><code>watch + iostat</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开一篇博客记录一下平时在linux环境使用到的工具，防止时间太久不使用之后被忘记。&lt;/p&gt;
&lt;h4 id=&quot;简单命令&quot;&gt;&lt;a href=&quot;#简单命令&quot; class=&quot;headerlink&quot; title=&quot;简单命令&quot;&gt;&lt;/a&gt;简单命令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang中的常用数据结构</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>golang中string是一个内置类型，它的默认值是<code>&quot;&quot;</code>，golang中的string的底层结构与C++的STL中的string是很类似的，golang中string是定长的，在底层结构的len中记录当前string的长度，它不支持扩容，但是golang依旧支持string的+/+=操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer<span class="comment">//指向一个[len]byte的数组</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span><span class="comment">//代表string的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string赋值"><a href="#string赋值" class="headerlink" title="string赋值"></a>string赋值</h4><p>当一个stirng赋值给另一个string时，仅仅是对结构体中的Pointer以及len进行值拷贝，这时候两个string对象就会指向同一块内存，很容易会想到浅拷贝的常见问题，但是实际上并不会出现浅拷贝的问题，<strong>通常string的内存会被编译器分配到只读区，该内存区域是不可写入的，当对字符串赋值时，对应字符串结构体中的Pointer会被修改为另一个地址，不会影响前一个字符串结构体中的地址</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span>s2 := s1s2 = <span class="string">"h"</span></span><br><span class="line"><span class="comment">//此时s2的Pointer与s1的Pointer不同</span></span><br></pre></td></tr></table></figure><p><em>使用fmt.Sprintf生成的字符串会被分配在堆空间</em></p><h4 id="操作"><a href="#操作" class="headerlink" title="+操作"></a><code>+</code>操作</h4><p>根据gdb调试发现<code>+</code>操作会调用<code>runtime/string.go</code>中的<code>concatstring2</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">n := <span class="built_in">len</span>(x)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l+n &lt; l &#123;</span><br><span class="line">throw(<span class="string">"string concatenation too long"</span>)</span><br><span class="line">&#125;</span><br><span class="line">l += n<span class="comment">//计算出两个字符串len的和</span></span><br><span class="line">count++<span class="comment">//保存要拼接的字符串的个数</span></span><br><span class="line">idx = i<span class="comment">//保存要拼接的最后一个字符串的index</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;<span class="comment">//表示传进来的字符串slice为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If there is just one string and either it is not on the stack</span></span><br><span class="line"><span class="comment">// or our result does not escape the calling frame (buf != nil),</span></span><br><span class="line"><span class="comment">// then we can return that string directly.</span></span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;<span class="comment">//count=1代表需要拼接的字符串只有一个，如果当前字符串位于只读区且buf不为nil则可以直接返回</span></span><br><span class="line"><span class="keyword">return</span> a[idx]</span><br><span class="line">&#125;</span><br><span class="line">s, b := rawstringtmp(buf, l)<span class="comment">//s指向string，此时的s长度为l,b指向s的Pointer内存缓冲区</span></span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;<span class="comment">//此时b string的长度即为a中的所有的string的长度总和，该步将a中的所有字符按顺序拷贝到buf中</span></span><br><span class="line"><span class="built_in">copy</span>(b, x)</span><br><span class="line">b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring2</span><span class="params">(buf *tmpBuf, a [2]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>var 数组名 [数组元素个数]数组元素类型{...}</code>定义数组，定义array与slice的区别就在于是否包含明确的元素个数，若有则为数组，数组不支持扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> array <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice与C++的STL中的vector类似，是一种动态的数组，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//slice append扩容机制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line"><span class="comment">// We assume that append doesn't need to preserve old.array in this case.</span></span><br><span class="line"><span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;<span class="comment">//旧元素个数小于1024则按照2倍扩容</span></span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span><span class="comment">//大于1024按照1.25倍扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// Specialize for common values of et.size.</span></span><br><span class="line"><span class="comment">// For 1 we don't need any division/multiplication.</span></span><br><span class="line"><span class="comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span></span><br><span class="line"><span class="comment">// For powers of 2, use a variable shift.</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line"><span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">capmem = roundupsize(capmem)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The check of overflow in addition to capmem &gt; maxAlloc is needed</span></span><br><span class="line"><span class="comment">// to prevent an overflow which can be used to trigger a segfault</span></span><br><span class="line"><span class="comment">// on 32bit architectures with this example program:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// var d T</span></span><br><span class="line"><span class="comment">// var s []T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func main() &#123;</span></span><br><span class="line"><span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line"><span class="comment">//   print(len(s), "\n")</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line"><span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line"><span class="comment">// Only shade the pointers in old.array since we know the destination slice p</span></span><br><span class="line"><span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;<span class="comment">//返回的是一个新的slice对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元素个数小于1024按照2倍扩容</li><li>元素个数大于等于1024按照1.25倍扩容</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>声明方式：</p><ul><li><strong>var 对象名 map[key_type]valuetype：仅仅进行声明会创建一个nil map，nil map是不能用来存放键值对的，也就是不能使用的</strong></li><li><strong>对象名 := make(map[key_type]value_type)：可以直接使用</strong></li><li><strong>map_obj_name := map[key_type][value_type]{“key1”:”value1”, “key2”: “value2”, …}</strong></li></ul><p>查看map中是否有某个key值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value, ok := map_obj_name[<span class="string">"key_name"</span>]</span><br><span class="line"><span class="comment">//如果key_name存在，则返回对应的value和true//如果key_name不存在，则返回nil和false</span></span><br></pre></td></tr></table></figure><h4 id="插入删除map中的元素"><a href="#插入删除map中的元素" class="headerlink" title="插入删除map中的元素"></a>插入删除map中的元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素：直接赋值，若key不存在则插入</span></span><br><span class="line">map_obj_name[key_name] = value</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="built_in">delete</span>(map_obj_name[key_name])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;string&quot;&gt;&lt;a href=&quot;#string&quot; class=&quot;headerlink&quot; title=&quot;string&quot;&gt;&lt;/a&gt;string&lt;/h3&gt;&lt;p&gt;golang中string是一个内置类型，它的默认值是&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;，g
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang jsonTag</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang%20jsonTag/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang%20jsonTag/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>json Tag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;    </span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span>    </span><br><span class="line">    Age <span class="keyword">int32</span> <span class="string">`json:"age"`</span>    </span><br><span class="line">    Class <span class="keyword">string</span> <span class="string">`json:"class"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag就是跟在结构体成员之后单引号中的内容，它的作用是用来当结构体对象进行编解码时，提供编/解码的方案。</p><p>举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>    </span><br><span class="line">    Age <span class="keyword">int32</span>    </span><br><span class="line">    Class <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student &#123;</span><br><span class="line">        Name: <span class="string">"ahaoozhang"</span>, </span><br><span class="line">        Age: <span class="number">18</span>,    </span><br><span class="line">        Class: <span class="string">"电信1605班"</span>,    </span><br><span class="line">    &#125;       </span><br><span class="line">    json, _ := json.Marshal(stu)<span class="comment">//对stu结构体进行json编码</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(json))<span class="comment">//打印json字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果为：</span></span><br><span class="line"><span class="comment">// &#123;"Name":"ahaoozhang","Age":18,"Class":"电信1605班"&#125;</span></span><br></pre></td></tr></table></figure><p>注意这种情况是在不包含jsonTag的情况下的编码结果，可以看出json字符串中的key与结构体成员名完全相同（包括大小写）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>  </span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> </span><br><span class="line">    Age <span class="keyword">int32</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Class <span class="keyword">string</span> <span class="string">`json:"class"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    stu := Student &#123;     </span><br><span class="line">        Name: <span class="string">"ahaoozhang"</span>,  </span><br><span class="line">        Age: <span class="number">18</span>,  </span><br><span class="line">        Class: <span class="string">"电信1605班"</span>,   </span><br><span class="line">    &#125;       </span><br><span class="line">    json, _ := json.Marshal(stu)<span class="comment">//对stu结构体进行json编码</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(json))<span class="comment">//打印json字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果为：</span></span><br><span class="line"><span class="comment">// &#123;"name":"ahaoozhang","age":18,"class":"电信1605班"&#125;</span></span><br></pre></td></tr></table></figure><p>可以看出在使用了jsonTag的情况下，编码后的json字符串Key与jsonTag中的内容一致。</p><p>Tag的功能并不止于此，结构体的一个成员可以有多个Tag，多个Tag之间使用空格隔开</p><p>通常一个jsonTag可以分为两部分，分别为属性名和选项，这两部分使用,隔开，属性名也就是上面所说的编/解码时替换Key的功能，通常使用的选项分别有<code>&quot;-&quot;</code>和<code>omitempty</code></p><ul><li><code>-</code>：在编/解码时直接忽略当前属性</li><li><code>omitempty</code>：在编/解码时，如果当前属性的值为空（nil）,则忽略当前属性</li><li><code>string</code>：在编/解码时，将对应的value转换为json的string类型</li></ul><p>举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (   </span><br><span class="line">    <span class="string">"fmt"</span>  </span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"-"`</span>   </span><br><span class="line">    Age <span class="keyword">int32</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Class <span class="keyword">string</span> <span class="string">`json:"class"`</span> </span><br><span class="line">    Ptr <span class="keyword">uintptr</span> <span class="string">`json:"ptr,omitempty"`</span> </span><br><span class="line">    Num <span class="keyword">int32</span> <span class="string">`json:"num,string"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    stu := Student &#123;    </span><br><span class="line">        Name: <span class="string">"ahaoozhang"</span>, </span><br><span class="line">        Age: <span class="number">18</span>,    </span><br><span class="line">        Class: <span class="string">"电信1605班"</span>, </span><br><span class="line">        Num: <span class="number">2000</span>,  </span><br><span class="line">    &#125;      </span><br><span class="line">    json, _ := json.Marshal(stu)<span class="comment">//对stu结构体进行json编码</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(json))<span class="comment">//打印json字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果为：&#123;"age":18,"Class":"电信1605班","num":"2000"&#125;</span></span><br></pre></td></tr></table></figure><p>问题：在使用<code>-</code>选项时，jsonTag必须只包含<code>-</code>，才能完全忽略当前属性的编/解码</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>使用<a href="https://golang.org/pkg/reflect/#StructTag" target="_blank" rel="noopener">reflect包</a>可以获取到结构体的jsonTag，除了反射机制可以获得jsonTag以外，对于其他方式jsonTag都是不可见的。</p><p>这里主要介绍<code>func (tag StructTag) Get(key string) string</code>函数，该函数可以用来获取指定key的value。</p><p>提取jsonTag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span> </span><br><span class="line">    <span class="string">"encoding/json"</span>  </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"-" xml:"NAME"`</span></span><br><span class="line">    Age <span class="keyword">int32</span> <span class="string">`json:"age" xml:"AGE"`</span> </span><br><span class="line">    Class <span class="keyword">string</span> <span class="string">`json:"class"`</span></span><br><span class="line">    Ptr <span class="keyword">uintptr</span> <span class="string">`json:"ptr,omitempty"`</span>   </span><br><span class="line">    Num <span class="keyword">int32</span> <span class="string">`json:"num,string"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student &#123;  </span><br><span class="line">        Name: <span class="string">"ahaoozhang"</span>, </span><br><span class="line">        Age: <span class="number">18</span>,    </span><br><span class="line">        Class: <span class="string">"电信1605班"</span>,   </span><br><span class="line">        Num: <span class="number">2000</span>,  </span><br><span class="line">    &#125;      </span><br><span class="line">    stutype := reflect.TypeOf(stu) </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stutype.NumField(); i++ &#123;  </span><br><span class="line">        field := stutype.Field(i)     </span><br><span class="line">        fmt.Printf(<span class="string">"json: %v; xml: %v\n"</span>,   field.Tag.Get(<span class="string">"json"</span>), field.Tag.Get(<span class="string">"xml"</span>))   </span><br><span class="line">        fmt.Printf(<span class="string">"%v\n"</span>, )   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果： * json: -; xml: NAME * json: age; xml: AGE * json: ; xml:  * json: num,string; xml:*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;json Tag&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang协程调度</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.100Z</updated>
    
    <content type="html"><![CDATA[<h4 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h4><h5 id="P"><a href="#P" class="headerlink" title="P"></a>P</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P的状态</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// P status</span></span><br><span class="line">_Pidle    = <span class="literal">iota</span></span><br><span class="line">_Prunning <span class="comment">// P的状态只能从_Prunning改变</span></span><br><span class="line">_Psyscall</span><br><span class="line">_Pgcstop</span><br><span class="line">_Pdead</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>程序中的P会在程序启动的时候初始化完成并链接在sched全局调度器的pidle队列中。</p><h5 id="G"><a href="#G" class="headerlink" title="G"></a>G</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协程状态</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// G status</span></span><br><span class="line">_Gidle = <span class="literal">iota</span> <span class="comment">// 空闲的G</span></span><br><span class="line">_Grunnable <span class="comment">// 可以被调度的G</span></span><br><span class="line">_Grunning <span class="comment">// 正在被调度的G</span></span><br><span class="line">_Gsyscall <span class="comment">// 陷入系统调用的G</span></span><br><span class="line">_Gwaiting <span class="comment">// 阻塞中的G</span></span><br><span class="line">_Gdead <span class="comment">// 未使用的G</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建一个g对象时，g会加入到本地或者全局队列。</p><h5 id="M"><a href="#M" class="headerlink" title="M"></a>M</h5><p>sysmon线程：该线程不用绑定P即可运行，内部是一个死循环：</p><ul><li>检查是否所有的协程都已经锁死，如果是的话直接调用runtime.throw强制退出，这个操作只在启动的时候做一次。</li><li>将netpoll返回的结果注入到全局的任务队列</li><li>收回因为进入系统调用二长时间阻塞的P，同时抢占那些执行时间过长的g</li><li>如果span的内存闲置超过5min，则释放掉</li></ul><h5 id="sched全局调度器"><a href="#sched全局调度器" class="headerlink" title="sched全局调度器"></a>sched全局调度器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">|</span><br><span class="line">------------P</span><br><span class="line">||</span><br><span class="line">_________________   |</span><br><span class="line">| | | | | | | | |   |</span><br><span class="line">g g g g g g g g g   G</span><br></pre></td></tr></table></figure><p>首先空闲的m会被链接进全局调度器的midle队列，当需要m的时候，会首先从这里取出m，如果此时没有可以使用的m，则调用newm来创建一个新的m。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    m    *m</span><br><span class="line">    atomicstatus   <span class="keyword">uint32</span><span class="comment">//记录g的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    curg guintptr       <span class="comment">// 当前正在被M运行的G</span></span><br><span class="line">    p    puintptr       <span class="comment">// 当前M绑定的P结构 </span></span><br><span class="line">    oldp puintptr       <span class="comment">// 陷入系统调用之前与m绑定的p</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    M muintptr    <span class="comment">// 当前P绑定的M</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前可以运行的G队列</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span>  </span><br><span class="line">    runqtail <span class="keyword">uint32</span>  </span><br><span class="line">    runq  [<span class="number">256</span>]guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以被重新使用的G队列 </span></span><br><span class="line">gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">gList</span><br><span class="line">n <span class="keyword">int32</span></span><br><span class="line">&#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">midle        muintptr <span class="comment">// 空闲的m组成的链表</span></span><br><span class="line">nmidle       <span class="keyword">int32</span>    <span class="comment">// number of idle m's waiting for work</span></span><br><span class="line">nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m's waiting for work</span></span><br><span class="line">mnext        <span class="keyword">int64</span>    <span class="comment">// number of m's that have been created and next M ID</span></span><br><span class="line">maxmcount    <span class="keyword">int32</span>    <span class="comment">// maximum number of m's allowed (or die)</span></span><br><span class="line">nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line"></span><br><span class="line">ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">pidle      puintptr <span class="comment">// 空闲的P组成的链表</span></span><br><span class="line">npidle     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的runnable状态的g队列</span></span><br><span class="line">runq     gQueue</span><br><span class="line">runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h4><ul><li>程序创建的G会被均匀分配在已经存在的P或者全局的Grunable队列上。</li><li>P在程序启动的时候会进行初始化，自golang1.5开始，GOMAXPROCS的默认值为CPU的核数。</li><li>当程序中存在可以被调度的P时，会先去寻找空闲的M与自身绑定，如果此时没有空闲的M，则就回去创建新的M。</li><li>M会从绑定的 P的本地队列、sched中的全局队列、netpoll中获取可运行的 G</li></ul><h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><h5 id="系统调用时机"><a href="#系统调用时机" class="headerlink" title="系统调用时机"></a>系统调用时机</h5><p>当运行的G陷入系统调用时，如果当前正在运行的G陷入阻塞或执行时间过久时，P的状态会该P的状态修改为Gsyscall，调度器会将P与当前M解绑，让当前的M与发生系统调用的G完美运行</p><p>放弃M的P会去哪里？</p><p>在golang的调度机制中，有一个特殊的M线程（sysmon），专门用来接收被抛弃的P，sysmon线程会周期性的醒来遍历所有的P，当发现有状态为Psyscall的P并且已经保持该状态一段时间，sysmon线程就会为当前的P重新分配一个M来执行</p><p>当被放弃的M结束系统调用之后会去绑定之前属于自己的P，如果此时sysmon线程还没有为P分配新的M，则P会与M重新绑定；当此时P已经与新的M进行绑定时，此时的M就会将自己挂起，等待系统分配新的空闲P</p><h5 id="chan读写时机"><a href="#chan读写时机" class="headerlink" title="chan读写时机"></a>chan读写时机</h5><p>当g发生向channel中写数据发现channel已经满的时候，P就会将当前的g挂起（分配到等待队列），并进行一次调度，知道有g对该channel进行读取时发现有阻塞写的g时会再次将被挂起的g唤醒</p><h5 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h5><p>sysmon协程除了检测处于Psyscall状态的P之外，还会检查处于Prunning状态的P，来避免某一个g占有M，并在某个时间剥夺该g进行调度，<a href="https://github.com/AHAOAHA/GoCode/tree/master/demo31-CPU" target="_blank" rel="noopener">CPU密集型协程占有M的问题</a></p><h4 id="协程状态"><a href="#协程状态" class="headerlink" title="协程状态"></a>协程状态</h4><p><img src= "/img/loading.gif" data-src="https://s2.ax1x.com/2019/07/08/ZrLLRJ.png" alt=""></p><p>创建协程从Gidle开始</p><p>Grunnable：处于该状态的协程随时都可能被调度器(P&amp;M)获取并执行</p><p>Grunning：该状态下的协程表明当前正在执行，在golang1.2之前的版本，一个正在运行的任务需要通过调用yield的方式显示的让出处理器；在go1.2之后开始支持一定程度的任务抢占-&gt;当系统线程发现某一个任务执行的时间过长或者在进行垃圾回收时，会将任务设置为”可被抢占”，当该任务下一次调用函数时，就会让出处理器并重新回到Grunnable状态</p><p>Gsyscall：Go为了保证高的并发性能，在执行系统调用时会先调用runtime.entersyscall将当前任务状态该为Gsycall，因为系统调用的权限更高，Go的调度器是在用户状态下的调度器，所以无法控制系统调用的执行，所以当系统调用是阻塞式或者执行时间过久时，就会将当前的M与P分离，M代表当前的运行线程，P则代表当前线程可以调度的协程任务队列，这表示P将被其他的M接管，所以当前的系统调用不会影响其他协程的调度。当系统调用返回后，执行线程M通过runtime.exitsyscall重新获取P继续进行P协程调度</p><p>Gwaiting：处于该状态的任务可以被看作处阻塞状态，只有当条件满足时，才可以进入Grunnable状态被调度运行，golang中的定时器、网络IO、chan都会导致协程处于当前状态。</p><p>Gdead：协程运行结束会调用runtime.goexit将状态设置为Gdead，并将结构体链接到一个属于当前P的空闲G链表中，以备后续使用。</p><h4 id="协程状态切换"><a href="#协程状态切换" class="headerlink" title="协程状态切换"></a>协程状态切换</h4><p>tls线程局部存储，可见性仅限于当前线程中，getg()用来获得当前线程正在执行的g。mcall()需要在进行协程切换时被调用，用来保存被切换出去的协程的信息。</p><p>调用时机：系统调用返回 协程阻塞 抢占式调度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;协程调度&quot;&gt;&lt;a href=&quot;#协程调度&quot; class=&quot;headerlink&quot; title=&quot;协程调度&quot;&gt;&lt;/a&gt;协程调度&lt;/h4&gt;&lt;h5 id=&quot;P&quot;&gt;&lt;a href=&quot;#P&quot; class=&quot;headerlink&quot; title=&quot;P&quot;&gt;&lt;/a&gt;P&lt;/h5&gt;&lt;f
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>GolandIDE常用快捷键</title>
    <link href="http://ahaoaha.top/2019/04/28/GolandIDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://ahaoaha.top/2019/04/28/GolandIDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.098Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查找文件-代码"><a href="#查找文件-代码" class="headerlink" title="查找文件/代码"></a>查找文件/代码</h4><ol><li><code>shift + shift</code>全局搜索，<code>ctrl + N</code>相同功能，在使用过程中经常会在切换中英文的时候唤醒全局搜索窗口，所以双击shift操作我是不太喜欢的。</li><li><code>ctrl + shift + N</code>全局搜索文件</li><li><code>ctrl + shift + alt + N</code>搜索函数或变量，全局工程中</li><li><code>ctrl + e</code>快速查找文件</li><li><code>ctrl + f</code>在当前窗口查找代码</li><li><code>ctrl + shift + f</code>全局代码搜索，代码搜索</li><li><code>ctrl + e</code>显示最近打开的文件</li></ol><h4 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h4><ol><li><code>ctrl + shift + b</code>光标位于变量/类型转类型定义处</li><li><code>F4</code>光标位于变量处，转变量定义处</li><li><code>ctrl +g</code>使用<code>行:列</code>方式定位光标位置，可以单独使用行定位，不可以单独使用列定位</li><li><code>ctrl + shift + F7</code>光标位于变量处，高亮显示当前变量在当前窗口中的出现位置</li><li><code>ctrl + h</code>光标位于变量/类型处，显示当前类型（结构体）的结构</li><li><code>ctrl + q</code>显示光标处函数的注释信息</li><li><code>alt + 上/下</code>光标跳转到当前作用域的上/下一个函数</li><li><code>shift + Esc</code>光标返回编辑框并关闭无用的窗口</li><li><code>ctrl + PageUp/PageDown</code>光标跳转到第一行或最后一行</li><li><code>shift + enter</code>直接换行，无论光标在当前行的什么位置</li><li><code>ctrl + alt + 左/右</code>回到上一个/下一个编辑位置</li><li><code>ctrl + 鼠标左键</code>进入函数定义处</li></ol><h4 id="代码替换"><a href="#代码替换" class="headerlink" title="代码替换"></a>代码替换</h4><ol><li><code>ctrl + R</code>在当前窗口搜索代码并替换</li><li><code>ctrl + shift + R</code>在全局搜索文本并替换</li><li><code>ctrl + shift + 上/下</code>将光标所在处的整个作用域向上/下移动</li><li><code>ctrl + /</code>注释/取消注释选定内容，所有选定内容单行注释</li><li><code>ctrl + D</code>复制光标所在行的整行并插入粘贴到下一行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查找文件-代码&quot;&gt;&lt;a href=&quot;#查找文件-代码&quot; class=&quot;headerlink&quot; title=&quot;查找文件/代码&quot;&gt;&lt;/a&gt;查找文件/代码&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;shift + shift&lt;/code&gt;全局搜索，&lt;code&gt;ctrl + 
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang-defer的使用</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang-defer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang-defer%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>在golang中<code>defer</code>关键字用来在函数return或者panic之前完成一些动作，经常用来释放资源等，<code>defer</code>的执行时机如下：</p><ol><li><strong>保存返回值</strong></li><li><strong>执行defer动作</strong></li><li><strong>执行空return</strong></li></ol><h4 id="defer执行的顺序"><a href="#defer执行的顺序" class="headerlink" title="defer执行的顺序"></a>defer执行的顺序</h4><p>如果一个函数中有多个defer动作，那么这些defer动作的执行顺序类似于栈，先被注册则最后被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的结果为</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="defer的用途一：回收资源"><a href="#defer的用途一：回收资源" class="headerlink" title="defer的用途一：回收资源"></a>defer的用途一：回收资源</h4><p>虽然golang是一款有GC的语言，但是在特定的情况下，某些资源还是需要程序员手动释放，类似互斥锁的关闭，chan的关闭，套接字的关闭等，defer可以在函数退出的时候来释放这些资源。</p><h4 id="defer的用途二：捕获panic"><a href="#defer的用途二：捕获panic" class="headerlink" title="defer的用途二：捕获panic"></a>defer的用途二：捕获panic</h4><p>如果代码中发生panic，则发生panic之后的代码就不会再被执行，但defer中的动作会被执行，所以通常可以在defer中对代码中的panic进行recover，使程序不会因为panic而异常退出，recover只有在defer中才有意义，如果在defer之外，发生panic之后，recover就不会被执行到了。</p><h4 id="defer函数的参数"><a href="#defer函数的参数" class="headerlink" title="defer函数的参数"></a>defer函数的参数</h4><p>defer函数的参数会在声明defer的时被确定，即使在defer之后参数被修改也不会影响defer原本的参数内容。</p><h4 id="defer的执行方式"><a href="#defer的执行方式" class="headerlink" title="defer的执行方式"></a>defer的执行方式</h4><p>golang编译器在编译的时候，会将defer转换为相应的函数调用，在声明defer的<code>CALL runtime.deferproc</code>，然后再函数返回之前CALL runtime.deferreturn`</p><ul><li>runtime.deferproc</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123; <span class="comment">// arguments of fn follow fn</span></span><br><span class="line">    <span class="comment">//getg函数用来获取当前正在执行的goroutine信息</span></span><br><span class="line"><span class="keyword">if</span> getg().m.curg != getg() &#123;</span><br><span class="line"><span class="comment">// go code on the system stack can't defer</span></span><br><span class="line">throw(<span class="string">"defer on system stack"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the arguments of fn are in a perilous state. The stack map</span></span><br><span class="line"><span class="comment">// for deferproc does not describe them. So we can't let garbage</span></span><br><span class="line"><span class="comment">// collection or stack copying trigger until we've copied them out</span></span><br><span class="line"><span class="comment">// to somewhere safe. The memmove below does that.</span></span><br><span class="line"><span class="comment">// Until the copy completes, we can only call nosplit routines.</span></span><br><span class="line">    </span><br><span class="line">sp := getcallersp()</span><br><span class="line">argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line"></span><br><span class="line">d := newdefer(siz)</span><br><span class="line"><span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"deferproc: d.panic != nil after newdefer"</span>)</span><br><span class="line">&#125;</span><br><span class="line">d.fn = fn</span><br><span class="line">d.pc = callerpc</span><br><span class="line">d.sp = sp</span><br><span class="line"><span class="keyword">switch</span> siz &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Do nothing.</span></span><br><span class="line"><span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">memmove(deferArgs(d), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line"><span class="comment">// a deferred func that stops a panic</span></span><br><span class="line"><span class="comment">// makes the deferproc return 1.</span></span><br><span class="line"><span class="comment">// the code the compiler generates always</span></span><br><span class="line"><span class="comment">// checks the return value and jumps to the</span></span><br><span class="line"><span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">return0()</span><br><span class="line"><span class="comment">// No code can go here - the C return register has</span></span><br><span class="line"><span class="comment">// been set and must not be clobbered.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime.deferreturn</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的参数arg0就是defer后面对应的要调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sp := getcallersp()</span><br><span class="line"><span class="keyword">if</span> d.sp != sp &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Moving arguments around.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Everything called after this point must be recursively</span></span><br><span class="line"><span class="comment">// nosplit because the garbage collector won't know the form</span></span><br><span class="line"><span class="comment">// of the arguments until the jmpdefer can flip the PC over to</span></span><br><span class="line"><span class="comment">// fn.</span></span><br><span class="line"><span class="keyword">switch</span> d.siz &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Do nothing.</span></span><br><span class="line"><span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">&#125;</span><br><span class="line">fn := d.fn</span><br><span class="line">d.fn = <span class="literal">nil</span></span><br><span class="line">gp._defer = d.link</span><br><span class="line">freedefer(d)</span><br><span class="line">jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>_defer</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A _defer holds an entry on the list of deferred calls.</span></span><br><span class="line"><span class="comment">// If you add a field here, add code to clear it in freedefer.</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">siz     <span class="keyword">int32</span></span><br><span class="line">started <span class="keyword">bool</span></span><br><span class="line">sp      <span class="keyword">uintptr</span> <span class="comment">// sp函数堆栈指针</span></span><br><span class="line">pc      <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">fn      *funcval <span class="comment">// 函数地址</span></span><br><span class="line">_panic  *_panic <span class="comment">// panic that is running defer</span></span><br><span class="line">link    *_defer <span class="comment">//指向自身结构体，用来链接多个defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>在同一个函数中，每次声明一个defer，就会向link的单链表中头插一个_defer结构体，当要执行defer时，也从单链表的头部拿出一个defer执行</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在golang中&lt;code&gt;defer&lt;/code&gt;关键字用来在函数return或者panic之前完成一些动作，经常用来释放资源等，&lt;code&gt;defer&lt;/code&gt;的执行时机如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保存返回值&lt;/strong&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell语法总结</title>
    <link href="http://ahaoaha.top/2019/04/28/Shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ahaoaha.top/2019/04/28/Shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.103Z</updated>
    
    <content type="html"><![CDATA[<p><code>#!</code>告诉系统其后面的路径指定的程序就是此脚本文件的shell程序。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>单行注释：<code>#</code></li><li>多行注释：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容 ...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="定义普通变量"><a href="#定义普通变量" class="headerlink" title="定义普通变量"></a>定义普通变量</h5><ul><li><code>变量名=变量值</code><ul><li>变量名和等号之间不能有空格</li><li>命名只能使用英文字母、数字、下划线，首字符不能以数字开头</li><li>变量名不能与bash关键字同名</li></ul></li><li><code>for</code>循环语法定义变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for file in `ls /etc`</span><br><span class="line">do</span><br><span class="line">echo $file</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印/etc下的所有文件</span></span><br></pre></td></tr></table></figure><h5 id="定义只读变量"><a href="#定义只读变量" class="headerlink" title="定义只读变量"></a>定义只读变量</h5><ul><li>使用<code>readonly</code>关键字可以将普通变量定义为只读变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">readonly name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> name被声明为只读变量，如果代码中出现修改name的行为时，程序将会报错</span></span><br></pre></td></tr></table></figure><h5 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h5><ul><li>使用一个定义过的变量，需要在变量名前加上美元符<code>$</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">echo $name</span><br><span class="line">echo $&#123;name&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125;大括号可以有效的让代码解释器识别变量名的边界</span></span><br></pre></td></tr></table></figure><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><ul><li>使用关键字<code>unset</code>可以删除普通变量，<code>unset</code>不能删除只读变量，被删除的变量不能被再次使用</li></ul><h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5><ul><li>局部变量：仅在当前shell中有效的变量</li><li>环境变量：所有的程序都能访问的变量</li><li>shell变量</li></ul><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>定义字符串可以用单引号、双引号、也可以不用引号</p><blockquote><p>单引号字符串的限制：</p><ul><li>单引号字符串中的任何字符都会原样输出，在单引号字符串中使用变量是无效的</li><li>单引号字符串中不能使用转义字符</li></ul></blockquote><h6 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h6><ul><li>使用双引号拼接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">str="my name is $name"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在双引号字符串中使用变量名拼接字符串</span></span><br></pre></td></tr></table></figure><ul><li>使用单引号拼接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">str='my name is '$name''</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在单引号中使用变量需要另外使用单引号括起来</span></span><br></pre></td></tr></table></figure><h6 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h6><ul><li>使用<code>#</code>字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">echo $&#123;#name&#125; # 输出name字符串的长度</span><br></pre></td></tr></table></figure><h6 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">echo $&#123;name:1:4&#125; #从name字符串的第二个字符向后截取4个字符</span><br></pre></td></tr></table></figure><h6 id="查找字符串中字符第一次出现的位置"><a href="#查找字符串中字符第一次出现的位置" class="headerlink" title="查找字符串中字符第一次出现的位置"></a>查找字符串中字符第一次出现的位置</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name="ahaoozhang"</span><br><span class="line">echo `expr index "$name" oz` # 查找name字符串中o/z字符第一次出现的位置，哪一个先出现就返回哪一个的位置</span><br></pre></td></tr></table></figure><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li>shell数组中元素的类型不一定一致，数字、字符串等不同的元素可以位于同一个数组内</li></ul><h6 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h6><ul><li>统一初始化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr1=("ahaoozhang" 18 "man")</span><br><span class="line">arr2=(</span><br><span class="line">"ahaoozhang"</span><br><span class="line">18</span><br><span class="line">"nan"</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>单独元素赋值：可以不使用连续的下标赋值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr3[0]="ahaoozhang"</span><br><span class="line">arr3[2]=18</span><br><span class="line">arr3[3]="man"</span><br></pre></td></tr></table></figure><h6 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h6><ul><li><code>${数组名[数组下标]}</code></li></ul><h6 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h6><ul><li>使用<code>#</code>+<code>@</code>/<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr4=(1 2 3 4 5)</span><br><span class="line">length=$&#123;#arr4[@]&#125;</span><br><span class="line">length=$&#123;#arr4[*]&#125;</span><br></pre></td></tr></table></figure><h6 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h6><ul><li>标准for循环</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr5=("ahaoozhang" 18 "man")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 标准<span class="keyword">for</span>循环</span></span><br><span class="line">for((i=0;i&lt;$&#123;#arr5[@]&#125;;i++)); do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>for语法糖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr5=("ahaoozhang" 18 "man")</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> ... <span class="keyword">in</span> ... 无下标</span></span><br><span class="line">for item in $&#123;arr5[@]&#125; do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> ... <span class="keyword">in</span> ... 有下标</span></span><br><span class="line">for item in $&#123;!arr5[@]&#125; do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>while循环</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">arr5=("ahaoozhang" 18 "man")</span><br><span class="line">i=0</span><br><span class="line">while [ $i -lt $&#123;#arr5[@]&#125; ]</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">let i++</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> 语法格式</span></span><br><span class="line">if 条件判断</span><br><span class="line">then</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> <span class="keyword">else</span>语法格式</span></span><br><span class="line">if 条件判断</span><br><span class="line">then</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">else</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> <span class="keyword">else</span>-if <span class="keyword">else</span>语法格式</span></span><br><span class="line">if 条件判断1</span><br><span class="line">then</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">elif 条件判断2</span><br><span class="line">then</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">else</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">匹配值1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">;;</span><br><span class="line">匹配值2)</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标准<span class="keyword">for</span>循环</span></span><br><span class="line">for((变量;条件判断;变量动作)); do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法糖<span class="keyword">for</span></span></span><br><span class="line">for item in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while 条件判断</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 死循环 该写法不支持单行shell</span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取键盘输入</span></span><br><span class="line">while read R</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> R代表当前键盘输入的值</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h5 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h5><p>until循环指代执行一系列命令直到条件表达式为true时停止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">until 条件表达式</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h5 id="break-continue"><a href="#break-continue" class="headerlink" title="break/continue"></a>break/continue</h5><ul><li><code>break</code>跳出所有的循环</li><li><code>continue</code>仅跳出当前循环</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>条件表达式要放在[]方括号之间，并且两边必须要有空格</strong></p><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">echo "a==b"</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方括号与变量之间的空格是必须存在的</span></span><br></pre></td></tr></table></figure><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><ul><li>关系运算符只支持数字，不支持字符串。</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">检测两个数字是否相等，与==类似</td></tr><tr><td align="center">-ne</td><td align="center">检测两个数字是否不相等，与!=类似</td></tr><tr><td align="center">-gt</td><td align="center">检测左边的数是否大于右边，与&gt;类似</td></tr><tr><td align="center">-lt</td><td align="center">检测左边的数字是否小于与右边，与&lt;类似</td></tr><tr><td align="center">-ge</td><td align="center">检测左边的数字是否大于等于右边，与&gt;=类似</td></tr><tr><td align="center">-le</td><td align="center">检测左边的数字是否小于等于右边，与&lt;=类似</td></tr></tbody></table><p><em>因为在bash中<code>&lt; &lt;&lt; &gt; &gt;&gt;</code>被用作重定向符号，所以为了不引起歧义，所以使用上面的符号进行条件判断</em>。</p><h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h5><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">非运算</td></tr><tr><td align="center">-o</td><td align="center">或运算</td></tr><tr><td align="center">-a</td><td align="center">与运算</td></tr></tbody></table><p><em>在bash中<code>|</code>被用作管道符号，<code>&amp;</code>被用作后台运行符号</em>。</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑且</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td></tr></tbody></table><h5 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h5><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">判断两个字符串是否相等</td></tr><tr><td align="center">!=</td><td align="center">判断两个字符串是否不相等</td></tr><tr><td align="center">-z</td><td align="center">检测字符串长度是否为0</td></tr><tr><td align="center">-n</td><td align="center">检测字符串长度是否不为0</td></tr><tr><td align="center">$</td><td align="center">检测字符串是否为空</td></tr></tbody></table><h5 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h5><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-b FILEPATH</td><td align="center">判断文件是否为块设备</td></tr><tr><td align="center">-c FILEPATH</td><td align="center">判断文件是否为字符设备文件</td></tr><tr><td align="center">-d FILEPATH</td><td align="center">判断文件是否为目录文件</td></tr><tr><td align="center">-f FILEPATH</td><td align="center">判断文件是否为普通文件</td></tr><tr><td align="center">-g FILEPATH</td><td align="center">判断文件是否设置了SGID位</td></tr><tr><td align="center">-k FILEPATH</td><td align="center">判断文件是否设置了粘滞位</td></tr><tr><td align="center">-p FILEPATH</td><td align="center">判断文件是否是命名管道文件</td></tr><tr><td align="center">-u FILEPATH</td><td align="center">判断文件是否设置了SUID位</td></tr><tr><td align="center">-r FILEPATH</td><td align="center">判断文件是否可读</td></tr><tr><td align="center">-w FILEPATH</td><td align="center">判断文件是否可写</td></tr><tr><td align="center">-x FILEPATH</td><td align="center">判断文件是否可执行</td></tr><tr><td align="center">-s FILEPATH</td><td align="center">判断文件是否为空</td></tr><tr><td align="center">-e FILEPATH</td><td align="center">检测文件是否存在</td></tr></tbody></table><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>返回值：如果函数没有添加返回值，会以最后一条命令的运行结果作为返回值。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">demoFunc() &#123;</span><br><span class="line">echo "hello world!"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h5><ul><li>使用<code>$n</code>获取参数：当参数超过10个时，需要使用{}为解释器指明目标参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">demoFunc() &#123;</span><br><span class="line">echo "第一个参数$1"</span><br><span class="line">echo "第一个参数$2"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用函数名可以执行函数</span></span><br><span class="line">demoFunc 1 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个参数1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个参数2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">$#</td><td align="center">参数个数</td></tr><tr><td align="center">$*</td><td align="center">以一个单字符串传递所有参数</td></tr><tr><td align="center">$$</td><td align="center">脚本运行的当前进程PID号</td></tr><tr><td align="center">$!</td><td align="center">后台运行的最后一个进程的PID号</td></tr><tr><td align="center">$@</td><td align="center">以一个单字符串传递所有参数，使用时加引号，并在引号中返回每个参数</td></tr><tr><td align="center">$-</td><td align="center">显示shell使用的当前选项，类似set</td></tr><tr><td align="center">$?</td><td align="center">显示最后命令的错误码</td></tr></tbody></table><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><table><thead><tr><th align="center">重定向符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">process &gt; file</td><td align="center">将进程的标准输出重定向到文件file</td></tr><tr><td align="center">process &lt; file</td><td align="center">将进程的标准输入重定向到文件file</td></tr><tr><td align="center">process &gt;&gt; file</td><td align="center">将进程的标准输出以追加方式重定向到文件file</td></tr><tr><td align="center">n &gt; file</td><td align="center">将文件描述符为n的文件重定向到文件file</td></tr><tr><td align="center">n &gt;&gt; file</td><td align="center">将文件描述符为n的文件以追加方式重定向到文件file</td></tr><tr><td align="center">n &gt;&amp; m</td><td align="center">将输出文件m和n合并</td></tr><tr><td align="center">n &lt;&amp; m</td><td align="center">将输入文件m和n合并</td></tr><tr><td align="center">&lt;&lt; tag</td><td align="center">将开始标记tag和结束标记tag之间的内容作为输出</td></tr></tbody></table><h5 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h5><ul><li>任何写入<code>/dev/null</code>的内容都将会被抛弃，相当与系统垃圾桶</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;#!&lt;/code&gt;告诉系统其后面的路径指定的程序就是此脚本文件的shell程序。&lt;/p&gt;
&lt;h4 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;单行注释：&lt;code
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang基础语法总结</title>
    <link href="http://ahaoaha.top/2019/04/28/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ahaoaha.top/2019/04/28/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-10-14T13:55:09.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><ul><li><strong>golang以包（文件夹）作为管理单位</strong></li><li><strong>每一个<code>xxx.go</code>文件必须先声明所属包</strong></li><li><strong>一个程序中必须有一个main包</strong></li><li><strong>导入的包必须进行使用，否则会编译报错</strong>，<em>在VsCode编辑器下，保存<code>xxx.go</code>文件时，未使用的包会自动进行删除</em></li><li><strong>golang中的init函数会在main函数开始之前执行，当init函数执行完成之后，main函数才会开始执行</strong></li></ul><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><p>golang对代码规范要求十分严格，不规范代码会产生各种问题。</p><ul><li><strong>函数的第一个括号必须和函数名位于同一行</strong></li><li><strong>if语句的第一个括号必须与if位于同一行</strong></li><li><strong>else语句必须与其对应的if的上一个右括号以及自身左括号位于同一行</strong></li><li><strong>switch语句的右括号必须与switch在同一行</strong></li></ul><h4 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h4><ul><li><strong><code>fmt</code>：包含IO相关的函数</strong></li></ul><h4 id="golang关键字"><a href="#golang关键字" class="headerlink" title="golang关键字"></a>golang关键字</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">default</span> <span class="keyword">break</span> <span class="function"><span class="keyword">func</span> <span class="title">interface</span> <span class="title">select</span> <span class="title">case</span> <span class="title">defer</span> <span class="title">go</span> <span class="title">map</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">chan</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="keyword">package</span> <span class="keyword">switch</span> <span class="keyword">const</span> <span class="keyword">fallthrough</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">range</span> <span class="keyword">type</span> <span class="keyword">continue</span> <span class="keyword">for</span> <span class="keyword">import</span> <span class="keyword">return</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure><h4 id="内建常量"><a href="#内建常量" class="headerlink" title="内建常量"></a>内建常量</h4><ul><li><strong><code>true false</code></strong></li><li><strong><code>iota</code></strong></li><li><strong><code>nil</code></strong></li></ul><h4 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span> <span class="keyword">complex128</span> <span class="keyword">complex64</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">byte</span> <span class="keyword">rune</span> <span class="keyword">string</span> error</span><br></pre></td></tr></table></figure><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line"><span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">函数名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">len、cap</td><td align="center">len用于返回某个类型的长度或数量（字符串、数组、切片、map、管道）；cap用于返回某个类型的最大容量（只可用于切片和map）</td></tr><tr><td align="center">new、make</td><td align="center">new和make都用于内存分配：new用于值类型和用户定义的类型，make用于内置类型（切片、map、管道）</td></tr><tr><td align="center">copy、append</td><td align="center">copy用于复制切片；append用于连接切片</td></tr><tr><td align="center">panic、recover</td><td align="center">两者均用于错误处理机制；panic类似于C语言中的perror</td></tr><tr><td align="center">print、println</td><td align="center">底层打印函数</td></tr><tr><td align="center">complex、read、imag</td><td align="center">complex用于创建复数；read用于提出复数的实部；imag用于提取复数的虚部</td></tr></tbody></table><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><ul><li><p><strong>使用var关键字：<code>var 变量名 变量类型</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span><span class="comment">//声明的变量必须使用，否则会产生错误</span></span><br><span class="line">    a = <span class="number">1</span><span class="comment">//变量赋值</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="keyword">var</span> b, c <span class="keyword">int</span></span><br><span class="line">    b, c = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用var关键字声明变量的初始化方式：</span></span><br><span class="line"><span class="comment">//1.声明之后采用赋值</span></span><br><span class="line"><span class="comment">//2.var 变量名 变量类型 = 变量初始值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>var自动推导类型：var 变量名 = 变量初始值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span><span class="comment">//定义变量+初始化</span></span><br><span class="line">    b, c := <span class="number">3</span>, <span class="number">3.1415</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>:=</code>自动推导类型：<code>变量名 := 变量初始化的值</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span><span class="comment">//定义变量+初始化</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        b = <span class="number">3</span></span><br><span class="line">        c = <span class="number">3.1415</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>声明一个变量未进行初始化时，该变量的值默认为零值。</li><li>对于同一个变量，<code>:=</code>在其生命周期中只能使用一次。</li></ul></blockquote><p><em>交换两个变量的值</em>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">3</span></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><ul><li><p><strong><code>_</code>：表示匿名变量，通常使用匿名变量接收的值会被丢弃</strong></p><blockquote><p>使用场景：当一个函数返回两个数据时，只想使用第一个不使用第二个，此时就可以用匿名变量接收第二个返回值。</p></blockquote></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h4><ul><li><p><strong>使用const关键字：<code>const 常量名 常量类型 = 常量值</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a <span class="keyword">int</span> = <span class="number">1</span><span class="comment">//声明常量必须进行初始化</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>*<em>自动推导类型：<code>const 常量名 = 常量值</code> *</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span><span class="comment">//常量推导类型使用=，与变量不同</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="内建类型-1"><a href="#内建类型-1" class="headerlink" title="内建类型"></a>内建类型</h4><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li><p><strong>声明格式：<code>var 数组名 [元素个数]元素类型</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span><span class="comment">//具有5个int元素的数组，未进行初始化，元素默认为零值</span></span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="comment">//定义并直接初始化</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><ul><li><p><strong>声明格式：<code>var 切片名 []切片类型</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sic1 []<span class="keyword">int</span><span class="comment">//声明含有多个未知元素的切片</span></span><br><span class="line"><span class="keyword">var</span> sic2 []<span class="keyword">int</span>&#123;&#125;<span class="comment">//声明空切片</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>append</code>函数可以为切片追加内容</strong></p></li><li><p><strong>使用<code>[]</code>可以对数组进行切片操作：<code>[开始位置:结束位置]</code>所切区域为前闭后开</strong></p></li><li><p><strong>切片内含扩容机制，以2倍方式增容</strong></p></li></ul><h5 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h5><ul><li><p><strong><code>type 结构体名 struct {}</code>：右括号必须和type在同一行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id <span class="keyword">int32</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">&#125;<span class="comment">//声明一个结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ahaoo student<span class="comment">//创建结构体对象</span></span><br><span class="line">    ahaoo.id = <span class="number">1</span></span><br><span class="line">    ahaoo.name = ahao</span><br><span class="line">    fmt.Println(ahaoo.id, ahaoo.name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nar student = &#123;<span class="number">2</span>, <span class="string">"nar"</span>&#125;</span><br><span class="line">    fmt.Println(nar.id, nar.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h5><ul><li><p><strong>使用iota+const关键字</strong></p><ul><li><strong>iota为常量自动生成器， 每隔一行自动累加1</strong></li><li><strong>iota给常量赋值使用</strong></li><li><strong>iota遇到const就会重置为0</strong></li><li><strong>同一个const中可以只写一个iota</strong></li><li><strong>如果iota位于同一行，则值相同</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">r = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">s = <span class="literal">iota</span><span class="comment">//1</span></span><br><span class="line">t = <span class="literal">iota</span><span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    u = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    v<span class="comment">//1</span></span><br><span class="line">    w<span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    u1 = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    v1, w1, x1 = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span><span class="comment">//1, 1, 1</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(r)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><strong>golang中的取地址符号是<code>&amp;</code></strong></p><ul><li><p><strong>普通指针：对变量/常量取地址的方式与C语言相同</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通指针的声明</span></span><br><span class="line"><span class="keyword">var</span> 指针名 *指针类型</span><br></pre></td></tr></table></figure></li><li><p><strong>函数指针：函数指针依然受限于参数列表</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针的声明方式</span></span><br><span class="line"><span class="comment">//1.推导类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">funcptr := test</span><br><span class="line"></span><br><span class="line"><span class="comment">//var声明</span></span><br><span class="line"><span class="keyword">var</span> 函数指针名 <span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>空指针：当声明指针未进行初始化时，指针的默认值为空指针</strong></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><strong><code>要转换的数据类型(变量名)</code>：类似C的类型转换</strong></li></ul><blockquote><ul><li>bool类型不能转换为整型，整型也不能转换为bool类型，这种不能转换的类型叫做不兼容类型。</li></ul></blockquote><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ul><li><strong><code>type 类型别名 类型原名</code></strong></li></ul><h3 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><ul><li><strong>左括号必须和if在同一行</strong></li></ul><h5 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h5><ul><li><strong>else必须和if的右括号以及自己的左括号在同一行</strong></li></ul><h5 id="if-else-if-…-else"><a href="#if-else-if-…-else" class="headerlink" title="if/else if/…/else"></a>if/else if/…/else</h5><ul><li><strong>else if必须和上一个右括号以及自己的左括号在同一行</strong></li></ul><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><h5 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始条件; 判断条件; 条件变换 &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="range关键字的使用"><a href="#range关键字的使用" class="headerlink" title="range关键字的使用"></a>range关键字的使用</h5><ul><li><strong>作用：迭代遍历切片/数组中的每一个元素，默认有两个返回值，第一个为元素下标，第二个为元素数据</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> array &#123;</span><br><span class="line">    <span class="comment">//k为array中元素的下标</span></span><br><span class="line">    <span class="comment">//v为array中元素的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> array &#123;</span><br><span class="line">    <span class="comment">//此时第二个返回值默认丢弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> array &#123;</span><br><span class="line">    <span class="comment">//此时第一个参数默认丢弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><ul><li><strong>golang保留break关键字，在switch语句中如果不写则默认添加</strong><ul><li><strong>break可用于for/switch/select</strong></li><li><strong>continue只可以用于for</strong></li></ul></li><li><strong>case后面可以跟多个条件</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先声明变量</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> num1 &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用初始化语句</span></span><br><span class="line"><span class="keyword">switch</span> num2 := <span class="number">1</span>; num1 &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch后面可以不添加参数</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> num &gt; <span class="number">90</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">90</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数定义的格式"><a href="#函数定义的格式" class="headerlink" title="函数定义的格式"></a>函数定义的格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回值变量名 返回值类型, 返回值变量名, 返回值类型...)</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数的声明由<code>func</code>关键字开始</strong></li><li><strong>FuncName：根据约定函数名首字母小写即为private，函数名首字母大写即为public</strong></li><li><strong>参数列表：函数可以有0/多个参数</strong></li><li><strong>返回值列表：函数可以返回0/多个返回值</strong><ul><li><strong>如果一个函数的返回值只有一个且不声明返回值变量，则返回值的括号可以省略</strong></li><li><strong>如果没有返回值就直接忽略最后的返回值信息</strong></li><li><strong>如果有返回值，那么必须在函数内部添加return语句</strong></li></ul></li></ul><h4 id="变长参数列表"><a href="#变长参数列表" class="headerlink" title="变长参数列表"></a>变长参数列表</h4><ul><li><p><strong>函数的最后一个参数是用<code>...类型名</code>命名就说明该函数的参数列表是一个不定长的参数列表</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func</span><span class="params">(...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变长参数列表传递的参数类似于该类型的slice，可使用for循环迭代</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h4><ul><li><strong>被<code>derfer</code>修饰的语句或函数会直到返回之后才会被执行</strong></li></ul><h3 id="golang并发"><a href="#golang并发" class="headerlink" title="golang并发"></a>golang并发</h3><ul><li><strong>使用<code>go 函数名</code>可以创建出一个协程执行对应函数</strong></li></ul><h3 id="golang面向对象"><a href="#golang面向对象" class="headerlink" title="golang面向对象"></a>golang面向对象</h3><p><strong>golang中没有类，但是它支持struct，struct是用户自定义类型（含方法），可以像其他语言中的类一样使用</strong>。</p><h4 id="定义struct成员函数"><a href="#定义struct成员函数" class="headerlink" title="定义struct成员函数"></a>定义struct成员函数</h4><ul><li><strong><code>(形式对象 结构体名)</code>被称为接收器条款，也就是只有通过该种类型的对象才能调用该函数</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(形式对象 结构体名)</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h4><p><strong>可以将一个匿名的类型嵌入彼此，如果将一个匿名的struct A嵌入另一个struct B，则A的接口也可以通过B对象来进行调用，但是A对象只能调用A自己的函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> .<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">    class</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> class <span class="keyword">struct</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//student的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st student)</span> <span class="title">GetName</span><span class="params">()</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> st.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl class)</span> <span class="title">FuncTest</span><span class="params">()</span><span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello this is class"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st student</span><br><span class="line">    <span class="keyword">var</span> cl class</span><br><span class="line">    st.name = <span class="string">"ahao"</span></span><br><span class="line">    st.id = <span class="number">1</span></span><br><span class="line">    Println(st.GetName())<span class="comment">//打印"ahao"</span></span><br><span class="line">    Println(st.FuncTest())<span class="comment">//打印"hello this is class"</span></span><br><span class="line">    </span><br><span class="line">    Println(cl.GetName())<span class="comment">//编译报错</span></span><br><span class="line">    Println(cl.FuncTest())<span class="comment">//打印"hello this is class"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>接口就是定义出一个类似于函数的集合，该集合中存在很多未进行定义的函数，当实现一个结构体时并且将该接口中的函数全部实现时，就成为结构体实现了该接口，体现了golang的多态性</p></blockquote><ul><li><p><strong>声明接口<code>interface</code></strong></p></li><li><p><strong>接口可以被任意的struct实现</strong></p><blockquote><p>一个接口struct实现接口中的所有方法才能算作实现接口，如果只实现部分接口，代码编译会出现panic</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Itfe <span class="keyword">interface</span> &#123;</span><br><span class="line">    Func1()</span><br><span class="line">    Func2()</span><br><span class="line">    Func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st student)</span> <span class="title">Func1</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"实现了Func1()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st student)</span> <span class="title">Func2</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"实现Func2()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st student)</span> <span class="title">Func3</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"实现Func3()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st student</span><br><span class="line">    st.name = <span class="string">"ahao"</span></span><br><span class="line">    st.id = <span class="number">1</span></span><br><span class="line">    st.Func1()<span class="comment">//打印"实现了Func1()"</span></span><br><span class="line">    st.Func2()<span class="comment">//打印"实现了Func2()"</span></span><br><span class="line">    st.Func3()<span class="comment">//打印"实现了Func3()"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="接口和结构体的关系"><a href="#接口和结构体的关系" class="headerlink" title="接口和结构体的关系"></a>接口和结构体的关系</h5><ul><li><strong>一个接口类型的对象可以作为函数的参数来接收实现了该接口的结构体对象</strong></li><li><strong>如果一个接口实现了某一个接口中的所有的方法，那么就可以认为这个接口实现了该接口，如果一个结构体实现了某一个接口，就说明这个结构体对象可以被参数为该接口类型的对象接收，当在函数内部通过该接口使用接口中的某一个方法时，会自动匹配对应结构体所实现的方法</strong></li><li>//接口与指针TODO</li></ul><h5 id="接口的类型判断"><a href="#接口的类型判断" class="headerlink" title="接口的类型判断"></a>接口的类型判断</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntFunc</span><span class="params">(INTERFACE_OBJ INTERFACE_TYPE)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> INTERFACE_OBJ.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> STRUCT_TYPE1:</span><br><span class="line">        <span class="comment">//DOSOMETHING</span></span><br><span class="line">        <span class="keyword">case</span> STRUCT_TYPE2:</span><br><span class="line">        <span class="comment">//DOSOMETHING</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//DOSOMETHING</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>传入的STRUCT_TYPE不需要使用 “ “ 标注</em></p><ul><li><strong>接口可以通过上述方式判断传入的结构体类型</strong></li></ul><h5 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h5><ul><li><strong>每一种类型都能匹配到空接口，也就是说可以使用空接口的作为函数的参数来接收任何类型的对象</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将空接口转换为INTERFACE_TYPE类型接口并进行INTERFACE_MOTHOD方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntFunc</span><span class="params">(INTERFACE_OBJ <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">RETURN_TYPE</span></span> &#123;</span><br><span class="line">    INTERFACE_OBJ.(INTERFACE_TYPE).INTERFACE_MOTHOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li><strong>golang在包级别进行封装，以小写字母开头的函数仅在当前包中有效</strong></li></ul><h3 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h3><ul><li><p><strong><code>import .&quot;PackageName&quot;</code>：在该文件中可以直接使用包中的函数，不需要<code>PackageName.Func()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> .<span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>import _&quot;PackageName&quot;</code>：当导入一个包时，该包文件下的所有init()函数都会被执行，然而有时候仅仅需要执行该包中的init()函数而已，这个时候就使用import _”PackageName”完成</strong>。</p></li></ul><ul><li><strong><code>struct{}{}</code>：通过<code>struct{}{}</code>可以创建匿名对象，该对象占有实际的内存空间，也可以在第二个括号内对第一个括号中定义的内容进行初始化</strong>。</li><li><strong><code>func init()</code>：init函数会在main函数开始执行之前执行，不同的包的init函数的执行顺序是根据包含包的顺序依次执行的，main包中的init函数会被最后执行</strong>。</li></ul><h3 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h3><ul><li><code>go build xxx.go</code>：编译代码生成可执行文件</li><li><code>go run xxx.go</code>：直接运行代码，不生成可执行文件，实际为build的一层封装</li><li><code>go vet xxx.go</code>：编码格式层面语法检测</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前提知识&quot;&gt;&lt;a href=&quot;#前提知识&quot; class=&quot;headerlink&quot; title=&quot;前提知识&quot;&gt;&lt;/a&gt;前提知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;golang以包（文件夹）作为管理单位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每一
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Golang过程中遇到的坑</title>
    <link href="http://ahaoaha.top/2019/04/28/%E4%BD%BF%E7%94%A8Golang%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://ahaoaha.top/2019/04/28/%E4%BD%BF%E7%94%A8Golang%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.107Z</updated>
    
    <content type="html"><![CDATA[<h4 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//fmt.Scanln(str)//这里直接使用str会让Scanln函数不阻塞，并且无法成功读取，应该使用&amp;str</span></span><br><span class="line">    fmt.Scanln(&amp;str)<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;str)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"str == nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[localhost User~]$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">[localhost User~]$ </span><br><span class="line"><span class="built_in">len</span>(str) == <span class="number">0</span></span><br><span class="line"><span class="comment">//直接键入回车，str为空</span></span><br></pre></td></tr></table></figure><h4 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1024</span>)</span><br><span class="line">   <span class="comment">//从c中接收一个值</span></span><br><span class="line">    str = &lt;-c</span><br><span class="line">   <span class="comment">//不是 str &lt;- c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bufio-ReadDir"><a href="#bufio-ReadDir" class="headerlink" title="bufio.ReadDir"></a>bufio.ReadDir</h4><blockquote><p><strong>遍历指定目录下的所有文件，将文件Stat组织成一个Slice返回，但是不包含文件夹中的隐藏文件</strong></p></blockquote><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><blockquote><p><strong>安装docker之后，linux机命令行localhost显示为bogon</strong></p></blockquote><h4 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h4><blockquote><p><strong>使用ResponseWriter.Head().Set时，必须确保此时未进行响应首行的发送，如果在发送首行之后设置头部，不会产生具体效果</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;fmt-Scanln&quot;&gt;&lt;a href=&quot;#fmt-Scanln&quot; class=&quot;headerlink&quot; title=&quot;fmt.Scanln&quot;&gt;&lt;/a&gt;fmt.Scanln&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Toml配置文件的使用</title>
    <link href="http://ahaoaha.top/2019/04/28/Toml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ahaoaha.top/2019/04/28/Toml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.104Z</updated>
    
    <content type="html"><![CDATA[<h4 id="toml的使用"><a href="#toml的使用" class="headerlink" title="toml的使用"></a>toml的使用</h4><p>下载第三方库：<code>go get github.com/BurntSushi/toml</code></p><p>toml的配置格式十分灵活，可以是整数（最小尺寸64位）、字符串（必须是utf-8编码）、数组、布尔值简单类型；也可以数组、map等复杂类型。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p>表格是键值对的集合，使用[]定义，一个表格的声明独占一行</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[TABLE_NAME]</span></span><br></pre></td></tr></table></figure><p>从一个表格声明开始，直到下一个表格或者文件EOF之前的内容都属于当前表格的键值对</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">KEY_NAME</span> = VALUE</span><br><span class="line"><span class="comment"># 键值可以随意缩进</span></span><br><span class="line">KEY_NAME2 = VALUE2</span><br></pre></td></tr></table></figure><p>嵌套表格的表格使用<code>.</code>标识</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[TABLE_NAME.SUB_TABLE_NAME]</span></span><br><span class="line"><span class="comment"># SUB_TABLE_NAME表格丛属于TABLE_NAME表格</span></span><br></pre></td></tr></table></figure><ul><li><p>例子</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dao.base]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">"ahaoaha"</span></span><br><span class="line"><span class="comment"># 对应的json</span></span><br><span class="line"><span class="comment"># &#123;"dao": &#123; "base": &#123;"type": "ahaoaha" &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="表格数组"><a href="#表格数组" class="headerlink" title="表格数组"></a>表格数组</h5><p>表格数组可以通过包裹在双中括号内的表格来表示，使用相同<code>[[TABLE_NAME]]</code>的表格是同一个数组的元素，表格按照书写的顺序插入，如果下方无键值对，则会被当作空表。</p><ul><li><p>例子</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[TABLE_NAME]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"ahaoozhang"</span></span><br><span class="line"><span class="attr">id</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[TABLE_NAME]]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[TABLE_NAME]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"gaoyuanyuan"</span></span><br><span class="line"><span class="attr">gender</span> = <span class="string">"woman"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于下面的json</span></span><br><span class="line">&#123;</span><br><span class="line">"TABLE_NAME": [</span><br><span class="line">&#123; "name": "ahaoozhang", id = "1" &#125;,</span><br><span class="line">&#123; &#125;,</span><br><span class="line">&#123; "name": "gaoyuanyuan", "gender": "woman" &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>表格数组也可以嵌套，只需要在子表格上使用双中括号语法，每一个子双中括号从属于最近定义的上方的表格</p><ul><li><p>例子</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[fruit]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"balana"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[fruit.physical]</span></span><br><span class="line"><span class="attr">color</span> = <span class="string">"yellow"</span></span><br><span class="line"><span class="attr">shape</span> = <span class="string">"round"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruit.variety]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"china"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruit.variety]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"USA"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruit]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruit.variety]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"plantain"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于下面的json结构</span></span><br><span class="line">&#123;</span><br><span class="line">"fruit": [</span><br><span class="line">&#123;</span><br><span class="line">"name": "balana",</span><br><span class="line">"physical": &#123;</span><br><span class="line">"color": "yellow",</span><br><span class="line">"shape": "round"</span><br><span class="line">&#125;,</span><br><span class="line">"variety": [</span><br><span class="line">&#123; "name": "china" &#125;,</span><br><span class="line">&#123; "name": "USA"&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">"name": "apple",</span><br><span class="line">"variety": [</span><br><span class="line">&#123; "name": "plantain"&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整个配置文件可以看作是一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局数据，直接可以解析到</span></span><br><span class="line"><span class="attr">title</span> = <span class="string">"标题"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个[]中括号类似一个结构体</span></span><br><span class="line"><span class="section">[user]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"ahaoozhang"</span></span><br><span class="line"><span class="attr">id</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">addr</span> = <span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="attr">port</span> = [<span class="number">8000</span>, <span class="number">8001</span>, <span class="number">8002</span>]</span><br><span class="line"><span class="attr">max_conn</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="section">[servers]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [servers]表示所属结构体，.后面的内容表示key值，val定义在下方</span></span><br><span class="line"><span class="section">[servers.alpha]</span></span><br><span class="line"><span class="attr">ip</span> = <span class="string">"10.1.1.1"</span></span><br><span class="line"><span class="attr">dc</span> = <span class="string">"eqdc10"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[severs.beta]</span></span><br><span class="line"><span class="attr">ip</span> = <span class="string">"10.0.0.0"</span></span><br><span class="line"><span class="attr">dc</span> = <span class="string">"eqdc10"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">data</span> = [[<span class="string">"gamma"</span>, <span class="string">"delta"</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="attr">hosts</span> = [<span class="string">"alpha"</span>, <span class="string">"omega"</span>]</span><br></pre></td></tr></table></figure><p><strong>在golang代码中，需要根据toml文件定义出相应的结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyConfig <span class="keyword">struct</span> &#123; <span class="comment">// 整个文件可以看作一个大的结构体</span></span><br><span class="line">    Title <span class="keyword">string</span> <span class="comment">// 全局字段可以直接提取</span></span><br><span class="line">    User UserInfo <span class="comment">// 每个[]对应一个结构体</span></span><br><span class="line">    DataBase DataBaseInfo</span><br><span class="line">    Servers <span class="keyword">map</span>[<span class="keyword">string</span>]server</span><br><span class="line">    Clients clients</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局结构体中的成员名需要与各表格名相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    ID <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataBaseInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP <span class="keyword">string</span></span><br><span class="line">    Port <span class="keyword">uint64</span></span><br><span class="line">    MaxConn <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP <span class="keyword">string</span></span><br><span class="line">    DC <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Clients <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data [][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Hosts []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := toml.DecodeFile(CONFIGFILEPATH, &amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;toml的使用&quot;&gt;&lt;a href=&quot;#toml的使用&quot; class=&quot;headerlink&quot; title=&quot;toml的使用&quot;&gt;&lt;/a&gt;toml的使用&lt;/h4&gt;&lt;p&gt;下载第三方库：&lt;code&gt;go get github.com/BurntSushi/toml&lt;/co
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>以太网数据帧和ARP协议</title>
    <link href="http://ahaoaha.top/2019/04/28/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%92%8CARP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://ahaoaha.top/2019/04/28/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%92%8CARP%E5%8D%8F%E8%AE%AE/</id>
    <published>2019-04-28T15:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.107Z</updated>
    
    <content type="html"><![CDATA[<h4 id="以太网数据帧"><a href="#以太网数据帧" class="headerlink" title="以太网数据帧"></a>以太网数据帧</h4><p>在以太网环境下，数据链路层的数据帧格式为：</p><p><img src= "/img/loading.gif" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzA3LzAxL1o4dk1mVS5wbmc" alt="Z8vMfU.png"></p><p>在以太网环境下，需要得知目的主机的mac地址才可以进行数据帧的发送，但是在数据帧从上层向下封装时，并无法得知目的主机的mac地址，所以在数据链路层进行数据帧格式的封装时，需要用到<strong>ARP协议</strong>。</p><blockquote><ul><li>前导码和帧开始符：以太网上的每一个数据帧都会7字节的前导码和1字节的帧开始符作为数据帧的开始，该部分是定值（10101010 10101010 10101010 10101010 10101010 10101010 10101010）</li><li>帧间距：作为数据帧的结束标识</li></ul></blockquote><hr><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>ARP协议的作用就是在发送方不知道目的主机的mac地址时，通过ARP协议可以获得目的主机的mac地址使得数据链路层完成数据帧的发送。</p><p>ARP协议格式：</p><p><img src= "/img/loading.gif" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzA3LzAxL1o4dlVrNi5wbmc" alt="Z8vUk6.png"></p><blockquote><ul><li>硬件类型：表明发送方硬件接口的类型，以太网为1</li><li>协议类型：表明发送方提供的高层协议类型，IP协议为0x0800</li><li>操作类型：用来表示当前报文的动作，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4</li></ul></blockquote><p>当数据报经过IP协议封装之后，就要在数据链路层进行帧打包，从以太网数据帧的结构中可以看出要对数据进行帧打包必须得到数据帧下一站的主机的mac地址。</p><p>所以在进行数据帧打包的上层以及IP协议封装的下层会使用ARP协议获得数据帧下一站主机的mac地址。</p><blockquote><ol><li>首先根据发送端主机的路由表确定下一站的IP地址</li><li>发送方主机会在本地ARP缓存中查找对应机器的mac地址，如果找到，则无需进行以下步骤</li><li>如果在发送方本地缓存中没有找到对应机器的mac地址，或者缓存过期时，发送方主机会进行ARP广播，将发送方主机的IP地址和mac地址都包含在ARP报文中对局域网中所有的主机进行广播（进行广播及就是将目的mac地址设置为FF FF FF FF）</li><li>局域网中的所以机器在收到ARP报文之后都会对报文中的目的IP地址与自身IP地址进行对比，如果不同则丢弃报文，相同时，目的机器会将发送方的IP和mac地址映射保存在自身机器的ARP缓存中，再将自身的mac地址通过ARP响应返回给发送方</li><li>发送方将目的机器的IP和mac地址映射保存进本机ARP缓存中，再对数据报文进行帧打包</li></ol></blockquote><p><em>通过<code>arp -a</code>可以查看当前机器上所有的ARP缓存</em>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;以太网数据帧&quot;&gt;&lt;a href=&quot;#以太网数据帧&quot; class=&quot;headerlink&quot; title=&quot;以太网数据帧&quot;&gt;&lt;/a&gt;以太网数据帧&lt;/h4&gt;&lt;p&gt;在以太网环境下，数据链路层的数据帧格式为：&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.g
      
    
    </summary>
    
    
      <category term="golang" scheme="http://ahaoaha.top/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是框架</title>
    <link href="http://ahaoaha.top/2019/04/26/1/"/>
    <id>http://ahaoaha.top/2019/04/26/1/</id>
    <published>2019-04-26T15:41:08.000Z</published>
    <updated>2019-09-08T05:10:57.106Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文所述为博主个人理解，如有错误欢迎在评论区指正</em>。</p><p>作为一个仅具有C/C++开发经验的人来说，首次接触框架，对框架的理解并不是十分的清晰。</p><p>起初，我认为框架就像是C/C++中封装好的库（类似STL），使用框架就像使用头文件一样，当按照我的理解去使用框架时，首先遇到的问题就是如何存放开源的框架代码，在C/C++中，STL早已经为开发者准备好了，只需要去包含它的头文件即可，但是开源的框架代码需要开发人员自己下载存放，第一次接触框架，这个问题造成了很大的瓶颈。</p><p><strong>框架并不同于库，抽象的来讲，框架就像一座大楼的整体结构，开发人员所做的事情就是利用代码来完善大楼；而库就像盖楼所需要的材料，开发人员不需要对材料再进行完善，直接拿来使用即可</strong>。</p><h2 id="框架的使用"><a href="#框架的使用" class="headerlink" title="框架的使用"></a>框架的使用</h2><p><em>本文内容基于golang</em>。</p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><ul><li><p>安装框架</p><blockquote><p>在自己的工作区内，使用命令行<code>go get github.com/xxx/xxx</code>即可将框架安装完成</p></blockquote></li></ul><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><ul><li><p>使用框架</p><blockquote><p>框架的使用需要某些工具（命令）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本文所述为博主个人理解，如有错误欢迎在评论区指正&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;作为一个仅具有C/C++开发经验的人来说，首次接触框架，对框架的理解并不是十分的清晰。&lt;/p&gt;
&lt;p&gt;起初，我认为框架就像是C/C++中封装好的库（类似STL），使用框架就像使用头文件一样，
      
    
    </summary>
    
    
      <category term="框架" scheme="http://ahaoaha.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树操作</title>
    <link href="http://ahaoaha.top/2019/04/15/1/"/>
    <id>http://ahaoaha.top/2019/04/15/1/</id>
    <published>2019-04-15T08:11:39.000Z</published>
    <updated>2019-09-08T05:10:57.106Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文代码托管于Github，阅读源码请<a href="https://github.com/AHAOAHA/Code/BinTreeOpt" target="_blank" rel="noopener">点击此处</a></strong></p><h1 id="前-中-后序遍历"><a href="#前-中-后序遍历" class="headerlink" title="前/中/后序遍历"></a>前/中/后序遍历</h1><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 遍历当前节点</span></span><br><span class="line">    PreOrder(root-&gt;left);</span><br><span class="line">    PreOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiddleOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MiddleOrder(root-&gt;left);</span><br><span class="line">    <span class="comment">//TODO 遍历当前节点</span></span><br><span class="line">    MiddleOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AfterOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AfterOrder(root-&gt;left);</span><br><span class="line">    AfterOrder(root-&gt;right);</span><br><span class="line">    <span class="comment">//TODO 遍历当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><blockquote><ul><li>从根节点向左走，将经历过的节点<strong>遍历</strong>并压栈，直到走到最后一个节点</li><li>拿出栈顶的节点，将cur该为该节点的右孩子</li><li>重复此过程，直到cur为空且栈为空</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NRPreOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO 遍历cur节点</span></span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.empty()) &#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h4><blockquote><ul><li>从根节点一直向左走，将经历过的节点压栈，直到最后一个节点</li><li>拿出栈顶节点，并进行<strong>遍历</strong>，将cur该为该节点的右孩子</li><li>重复此过程，直到cur为空且栈为空</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NRMiddleOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.push(cur);</span><br><span class="line">        cur = cur-&gt;left;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.empty()) &#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            <span class="comment">//TODO 遍历cur节点</span></span><br><span class="line">            st.pop();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><blockquote><ul><li>从根节点一直向右走<ul><li>当cur不为空，则将cur压入st和output</li><li>如果cur为空，拿出st栈中的栈顶元素并将该元素出栈，将cur该为该节点的左孩子</li></ul></li><li>重复此过程，当cur为空且st栈为空时，output栈的出栈顺序即为后序遍历顺序</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NRAfterOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; output;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            output.push(cur);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!output.empty()) &#123;</span><br><span class="line">        cur = output.top();</span><br><span class="line">        output.pop();</span><br><span class="line">        <span class="comment">//TODO 遍历cur节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序"><a href="#层序" class="headerlink" title="层序"></a>层序</h4><blockquote><ul><li>如果根节点为空，则返回</li><li>将根节点入队列，并进入循环</li><li>当队列中元素不为空时，取出队列头部的元素，并进行<strong>遍历</strong><ul><li>若该元素有左子树，将左子树入队列</li><li>若该元素有右子树，将右子树入队列</li></ul></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeverOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; qe;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    qe.push(cur);</span><br><span class="line">    <span class="keyword">while</span>(!qe.empty()) &#123;</span><br><span class="line">        cur = qe.front();</span><br><span class="line">        qe.pop();</span><br><span class="line">        <span class="comment">//TODO 遍历cur节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">            qe.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">            qe.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文代码托管于Github，阅读源码请&lt;a href=&quot;https://github.com/AHAOAHA/Code/BinTreeOpt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击此处&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://ahaoaha.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O多路转接</title>
    <link href="http://ahaoaha.top/2019/03/19/I-O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/"/>
    <id>http://ahaoaha.top/2019/03/19/I-O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/</id>
    <published>2019-03-19T15:14:11.000Z</published>
    <updated>2019-09-08T05:10:57.101Z</updated>
    
    <content type="html"><![CDATA[<p>在没有学习多路转接之前，我认为实现服务端最好的方式就是线程池+多线程服务器，要让服务器实现效率最大化，那么服务器中的线程数应该尽可能与CPU数量保持一致，我没有办法想象一个大型的商用服务器中究竟有多少个CPU，但是阿里云的学生服务器只是单核的，在我看来这个学生服务器并没有多大用处，甚至搭建一个网站在多人访问时也是十分困难的，但是事实并非如此。</p><p>本文代码托管于Github，阅读源码请<a href="https://github.com/AHAOAHA/CentOS_Code/tree/master/C%2B%2B/select_service" target="_blank" rel="noopener">点击此处</a></p><h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I/O"></a>高级I/O</h1><p><strong>在Linux中，我们可以将所有的I/O都分为两步，第一步就是等，第二步是数据拷贝</strong>。</p><p>在学习编程的初级阶段，就可以发现I/O是一种十分浪费资源的行为，而这种资源的浪费主要是存在I/O的第一个阶段，即就是等待阶段。</p><blockquote><p>对于I/O的理解，主要可以通过scanf函数，如果调用scanf函数，则执行流就会等待用户进行I/O操作，之后执行流才会执行下面的内容，但是scanf这种I/O模型只是Linux中I/O模型的一种。</p></blockquote><h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p><strong>阻塞式I/O就是执行流会阻塞在要发生I/O的位置，等待I/O时间的发生</strong>。</p><blockquote><p>阻塞式I/O是我目前最常见的I/O模型，从最早的scanf函数开始，就已经接触到了阻塞式I/O。</p></blockquote><h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p><strong>非阻塞式I/O表示执行流不会停在将要发生I/O的位置，当执行流到达I/O发生的位置，执行流会去检测目前I/O动作是否发生，如果没有发生则并不阻塞，而是设置error，可以去做另外的一些任务，但必须对I/O时间进行循环检测，该循环机制是由程序员来控制的</strong>。</p><blockquote><p>目前我接触过的非阻塞I/O并不多，仅仅是在做项目时使用过recv的非阻塞I/O模式。</p></blockquote><h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p><strong>信号驱动I/O是指执行流到达将要发生I/O的位置时也并不会去检测此时I/O是否发生，而是继续执行程序的代码，当I/O动作发生时，操作系统会向进程发送信号，此时进程就会立即进行数据的拷贝</strong>。</p><blockquote><p>键盘输入即就是一种信号驱动I/O，当键盘发生I/O动作时会立即触发CPU中断。</p></blockquote><h2 id="多路转接-多路复用I-O"><a href="#多路转接-多路复用I-O" class="headerlink" title="多路转接/多路复用I/O"></a>多路转接/多路复用I/O</h2><p><strong>多路转接I/O的意思是将多个文件描述符交给一个对象来管理，每一次检测，管理的对象就会检测相应的文件描述符是否有进行I/O行为</strong>。</p><h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p><strong>前四种I/O模型都是同步I/O，同步I/O必须自己进行等待和数据的拷贝，异步I/O不用自己进行等待和数据的拷贝</strong>。</p><h1 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h1><p><strong>一个文件描述符默认情况下都是采用阻塞I/O的</strong>。使用系统调用接口可以改变文件描述符的I/O模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>fd：<strong>要修改的目标文件描述符</strong>。</p></li><li><p>cmd：<strong>要对文件描述符进行的操作</strong>。</p><ul><li><strong>F_DUPFD：复制一个现有的文件描述符</strong>。</li><li><strong>F_GETFD/F_SETFD：获得/设置当前文件描述符标记</strong>。</li><li><strong>F_GETFL/F_SETFL：获得/设置当前文件描述符状态标记</strong>。</li><li><strong>F_GETOWN/F_SETOWN：获得异步I/O所有权</strong>。</li><li><strong>F_GETLK：获得记录锁</strong>。</li><li><strong>F_SETLK/F_SETLKW：设置记录锁</strong>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单例子：将标准输入文件描述符设置为非阻塞方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetNoBlock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fl = fcntl(fd, F_GETFL);<span class="comment">//获取当前文件描述符状态</span></span><br><span class="line">    <span class="keyword">if</span>(fl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(fd, F_SETFL, fl | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret = <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buf[ret] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reading ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多路转接"><a href="#多路转接" class="headerlink" title="多路转接"></a>多路转接</h1><h2 id="使用select实现多路转接"><a href="#使用select实现多路转接" class="headerlink" title="使用select实现多路转接"></a>使用select实现多路转接</h2><blockquote><p>多路转接即就是同时监视多个文件描述符是否发生I/O事件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">//该函数的返回值是很重要的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>nfds：<strong>nfds是指需要监视的文件描述符中最大的文件描述符+1</strong>。</p></li><li><p>readfds，writefds，exceptfds：<strong>分别对应需要检测的可读文件描述符的集合，可写文件描述符的集合，异常文件描述符的集合</strong>。</p><blockquote><p><strong>readfds、writefds、exceptfds是输入输出型参数</strong>：</p><ul><li><strong>当作为输入时，表示用户告诉内核需要监听的文件描述符</strong></li><li><strong>当作为输出时，表示内核告诉用户已经就绪的文件描述符</strong></li></ul></blockquote></li><li><p>timeout：<strong>用来设置select的等待时间</strong>。</p><blockquote><p>timeout == NULL：<strong>表示select没有timeout，select将会被一直阻塞，直到某个文件描述符上发生了事件</strong></p><p>timeout == 0：<strong>仅检测文件描述符集合的状态立即返回，并不等待外部事件的发生</strong></p><p>timeout == 特定事件值：<strong>如果在指定时间内没有时间发生，select将超时返回</strong></p></blockquote></li></ul><h3 id="操作fd-set的函数集"><a href="#操作fd-set的函数集" class="headerlink" title="操作fd_set的函数集"></a>操作fd_set的函数集</h3><blockquote><p><strong>虽然我们直到select使用位图来监听套接字的，但是直接使用位操作去操作fd_set是十分不方便也是十分不安全的，所以操作系统提供了一套操作fd_set的函数集</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//清除set位图中描述fd的位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//用来测试set位图中fd的位是否为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将fd设置进set的某一个位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//清除set位图中的所有位</span></span><br></pre></td></tr></table></figure><h3 id="select函数的返回值"><a href="#select函数的返回值" class="headerlink" title="select函数的返回值"></a>select函数的返回值</h3><ul><li><strong>当select函数成功返回时，返回值即代表状态已经发生改变的文件描述符的个数</strong></li><li><strong>如果返回值为0，则代表在文件描述符状态改变之前已经超过timewait时间</strong></li><li><strong>如果返回-1，则代表有错误发生，错误原因存在error中，此时readfds、writefds、exceptfds和timewait的值变得不可预测</strong></li></ul><h3 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h3><blockquote><ul><li><strong>select的输入输出是一个参数，每次调用select时必须对参数进行重新设定</strong></li><li><strong>select所能关心的文件描述符是有上限的，通常是1024，这个与fd_set的大小有关</strong></li><li><strong>select服务器当连接极度增加时，会导致效率降低</strong></li></ul></blockquote><h3 id="select服务器"><a href="#select服务器" class="headerlink" title="select服务器"></a>select服务器</h3><p>查看源码请<a href="https://github.com/AHAOAHA/CentOS_Code/tree/master/C%2B%2B/select_service" target="_blank" rel="noopener">点击此处</a>，如有bug请指出</p><h2 id="使用epoll实现多路转接"><a href="#使用epoll实现多路转接" class="headerlink" title="使用epoll实现多路转接"></a>使用epoll实现多路转接</h2><p><strong>epoll是目前公认的效率最高的服务器实现方式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个epoll模型</span></span><br><span class="line"><span class="comment">//自从Linux2.6.8之后，size参数是被忽略的</span></span><br><span class="line"><span class="comment">//当epoll模型使用完成之后必须使用close()接口关闭</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>epoll_create的返回值是一个文件描述符，当调用该接口时，操作系统会在内核中创建一个epoll模型：</strong></p><p><strong>创建一个epoll模型操作系统会做三件事情：</strong></p><ol><li><strong>创建就绪队列</strong></li><li><strong>创建一颗红黑树</strong><ul><li>直接用文件描述符作为key，对应的事件作为value</li></ul></li><li><strong>创建回调机制</strong></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"><span class="comment">//用来控制epoll模型</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>epfd：<strong>调用epoll_create时创建的文件描述符</strong></p></li><li><p>op：<strong>表示动作</strong></p><ul><li>EPOLL_CTL_ADD：注册新的fd到epoll中</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</li><li>EPOLL_CTL_DEL：从epoll中删除一个fd</li></ul></li><li><p>fd：<strong>表示要监听的文件描述符</strong>。</p></li><li><p>event：<strong>告诉内核要监听什么事件</strong></p><blockquote><p>struct epoll_event中events的取值：</p><ul><li>EPOLLIN：表示对应的文件描述符可以读（包括对端socket正常关闭）；</li><li>EPOLLOUT：表示对端文件描述符可以写；</li><li>EPOLLPRI：表示对端的文件描述符有紧急数据可以读</li><li>EPOLLERR：表示对应的文件描述符发生错误</li><li>EPOLLHUP：表示对应的文件描述符被挂断</li></ul><p>…未完待续</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//返回值即代表已经就绪的文件描述符个数</span></span><br></pre></td></tr></table></figure><blockquote><p>该接口的作用是内核告诉用户，对应的epoll模型中的哪些文件描述符的哪些事件已经就绪。</p></blockquote><h3 id="epoll服务器"><a href="#epoll服务器" class="headerlink" title="epoll服务器"></a>epoll服务器</h3><p>查看源码请<a href="https://github.com/AHAOAHA/CentOS_Code/tree/master/C%2B%2B/epoll" target="_blank" rel="noopener">点击此处</a>，如有bug请指出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在没有学习多路转接之前，我认为实现服务端最好的方式就是线程池+多线程服务器，要让服务器实现效率最大化，那么服务器中的线程数应该尽可能与CPU数量保持一致，我没有办法想象一个大型的商用服务器中究竟有多少个CPU，但是阿里云的学生服务器只是单核的，在我看来这个学生服务器并没有多
      
    
    </summary>
    
    
      <category term="网络" scheme="http://ahaoaha.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="http://ahaoaha.top/tags/Linux/"/>
    
  </entry>
  
</feed>
