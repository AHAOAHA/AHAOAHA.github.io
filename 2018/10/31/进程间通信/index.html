<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>进程间通信 | 苦心人，天不負，臥薪嘗膽，三千越甲可吞吳</title><meta name="description" content="进程间通信的方式管道 管道是Linux操作系统下的一种文件类型，该文件类型的文件就是为了给不同进程之间提供可以进行通信的文件资源。 一个管道只能单向通信。  为什么一个管道只能进行单向通信？ 一个进程可以对一个管道文件进行读或写操作，当两个进程通过一个管道进行通信时，一定是有一个进程对管道进行写操作，另一个管道进行读操作，这样就可以实现进程之间的单向通信，但假如两个进程同时将读写端口都打开时，两个"><meta name="keywords" content="Linux"><meta name="author" content="AHAOAHA"><meta name="copyright" content="AHAOAHA"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ahaoaha.top/2018/10/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="进程间通信"><meta property="og:url" content="http://ahaoaha.top/2018/10/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="苦心人，天不負，臥薪嘗膽，三千越甲可吞吳"><meta property="og:description" content="进程间通信的方式管道 管道是Linux操作系统下的一种文件类型，该文件类型的文件就是为了给不同进程之间提供可以进行通信的文件资源。 一个管道只能单向通信。  为什么一个管道只能进行单向通信？ 一个进程可以对一个管道文件进行读或写操作，当两个进程通过一个管道进行通信时，一定是有一个进程对管道进行写操作，另一个管道进行读操作，这样就可以实现进程之间的单向通信，但假如两个进程同时将读写端口都打开时，两个"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2018-10-31T03:56:29.000Z"><meta property="article:modified_time" content="2019-09-08T05:10:57.110Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="单例模式" href="http://ahaoaha.top/2018/11/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"><link rel="next" title="Linux下的文件操作" href="http://ahaoaha.top/2018/10/22/Linux%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  bookmark: {
    message_prev: '按',
    message_next: '鍵將本頁加入書籤'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="苦心人，天不負，臥薪嘗膽，三千越甲可吞吳" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">標籤</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分類</div><div class="length_num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目錄</div><div class="sidebar-toc__progress"><span class="progress-notice">你已經讀了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#进程间通信的方式"><span class="toc-number">1.</span> <span class="toc-text">进程间通信的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#管道"><span class="toc-number">1.1.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管道操作"><span class="toc-number">1.1.1.</span> <span class="toc-text">管道操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名管道"><span class="toc-number">1.1.2.</span> <span class="toc-text">匿名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现匿名管道"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">代码实现匿名管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名管道"><span class="toc-number">1.1.3.</span> <span class="toc-text">命名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口-1"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名管道与匿名管道的区别"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">命名管道与匿名管道的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现命名管道"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">代码实现命名管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道读写规则"><span class="toc-number">1.1.4.</span> <span class="toc-text">管道读写规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息队列"><span class="toc-number">1.2.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是消息队列"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC对象数据结构-usr-include-linux-ipc-h"><span class="toc-number">1.2.2.</span> <span class="toc-text">IPC对象数据结构 &#x2F;usr&#x2F;include&#x2F;linux&#x2F;ipc.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息队列数据结构-usr-include-linux-msg-h"><span class="toc-number">1.2.3.</span> <span class="toc-text">消息队列数据结构 &#x2F;usr&#x2F;include&#x2F;linux&#x2F;msg.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息队列中消息块的数据结构（自己定义）"><span class="toc-number">1.2.4.</span> <span class="toc-text">消息队列中消息块的数据结构（自己定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口："><span class="toc-number">1.2.5.</span> <span class="toc-text">接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装消息队列接口"><span class="toc-number">1.2.6.</span> <span class="toc-text">封装消息队列接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过封装好的消息队列接口实现client-amp-service互相通信"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">通过封装好的消息队列接口实现client&amp;service互相通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享内存"><span class="toc-number">1.3.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享内存数据结构"><span class="toc-number">1.3.1.</span> <span class="toc-text">共享内存数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#封装共享内存接口"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">封装共享内存接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用封装好的接口来验证共享内存"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">使用封装好的接口来验证共享内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量集"><span class="toc-number">1.3.3.</span> <span class="toc-text">信号量集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步与互斥"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#互斥"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">同步</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量结构体伪代码"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">信号量结构体伪代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">V</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量集结构体"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">信号量集结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口-3"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">接口</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">苦心人，天不負，臥薪嘗膽，三千越甲可吞吳</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">进程间通信</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="發表於 2018-10-31 11:56:29"><i class="far fa-calendar-alt fa-fw"></i> 發表於 2018-10-31</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新於 2019-09-08 13:10:57"><i class="fas fa-history fa-fw"></i> 更新於 2019-09-08</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>閱讀量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul>
<li>管道是Linux操作系统下的一种文件类型，该文件类型的文件就是为了给不同进程之间提供可以进行通信的文件资源。</li>
<li><strong>一个管道只能单向通信。</strong></li>
</ul>
<p>为什么一个管道只能进行单向通信？</p>
<p>一个进程可以对一个管道文件进行读或写操作，当两个进程通过一个管道进行通信时，一定是有一个进程对管道进行写操作，另一个管道进行读操作，这样就可以实现进程之间的单向通信，但假如两个进程同时将读写端口都打开时，两个进程都可以进行读或写操作，这样就会造成进程之间读取信息紊乱，所以一个管道只能进行单向通信，如果想要以管道的方式实现两个进程之间双向通信，就必须实现两个管道。</p>
<h3 id="管道操作"><a href="#管道操作" class="headerlink" title="管道操作"></a>管道操作</h3><p>图解管道操作（以匿名管道为例）：</p>
<p>1.父进程创建管道</p>
<p><a href="https://imgchr.com/i/iR5OoV" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2018/10/31/iR5OoV.png" alt="iR5OoV.png"></a></p>
<p>2.父进程fork出子进程</p>
<p><a href="https://imgchr.com/i/iRIpQJ" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2018/10/31/iRIpQJ.md.png" alt="iRIpQJ.md.png"></a></p>
<p>3.子进程关闭写端，父进程关闭读端</p>
<p><a href="https://imgchr.com/i/iRIVJO" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2018/10/31/iRIVJO.png" alt="iRIVJO.png"></a></p>
<p><strong>所以我们可以将管道视为文件，并且使用文件操作的方式去操作管道</strong>。</p>
<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><ul>
<li><strong>匿名管道只能用于有亲缘关系的两个进程之间的通信，通常用于子进程与父进程</strong>。</li>
<li><strong>匿名管道属于管道的一种，它同样只可以单向通信</strong>。</li>
<li><strong>匿名管道的生命周期随进程</strong>。</li>
<li><strong>匿名管道是面向字节流的</strong>。</li>
<li><strong>操作系统内核会对匿名管道进行同步于互斥</strong>。</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">接口功能：创建一个匿名管道文件</span><br><span class="line">参数：文件描述符数组，fd[<span class="number">0</span>]表示读端，fd[<span class="number">1</span>]表示写端</span><br></pre></td></tr></table></figure>

<h4 id="代码实现匿名管道"><a href="#代码实现匿名管道" class="headerlink" title="代码实现匿名管道"></a>代码实现匿名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *子进程向管道内写入10次，i am child...</span></span><br><span class="line"><span class="comment"> *父进程每隔1s从管道本读出一句i am child...</span></span><br><span class="line"><span class="comment"> *该进程的子进程与父进程未设置退出逻辑，需要使用[Ctrl+C]终止进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pipe(fd))<span class="comment">//匿名管道创建失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == id)<span class="comment">//子进程创建失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == id)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//关闭子进程读端</span></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, <span class="string">"i am child...\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//子进程写入完成时不退出，管道写端不关闭</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);<span class="comment">//关闭父进程的写端</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//子进程从管道读数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(wait(<span class="literal">NULL</span>)!=id);<span class="comment">//等待子进程退出</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//关闭读端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_pipe();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...    </span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br><span class="line">i am child...</span><br></pre></td></tr></table></figure>

<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><ul>
<li><strong>命名管道可以应用于两个毫不相干的进程之间的通信</strong>。</li>
<li><strong>命名管道是一种特殊类型的文件</strong>。</li>
</ul>
<h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">功能：在pathname路径下，创建一个命名管道文件</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	pathname：路径信息，表示管道文件将会创建在pathname路径下，不支持~</span><br><span class="line">	mode:管道文件权限信息，通常配合umask(<span class="keyword">mode_t</span> mode);使用</span><br></pre></td></tr></table></figure>

<h4 id="命名管道与匿名管道的区别"><a href="#命名管道与匿名管道的区别" class="headerlink" title="命名管道与匿名管道的区别"></a>命名管道与匿名管道的区别</h4><ul>
<li>匿名管道只能用于具有亲缘关系的进程之间的通信，命名管道可以用于任意两个进程之间的通信。</li>
<li>匿名管道用pipe()函数创建并打开，命名管道通过mkfifo()函数创建，由open()函数打开</li>
</ul>
<h4 id="代码实现命名管道"><a href="#代码实现命名管道" class="headerlink" title="代码实现命名管道"></a>代码实现命名管道</h4><p>通过命名管道实现client进程向service进程发送文本数据，该管道由service创建并销毁，client只打开并写入文本数据即可。client.c service.c pipe.h必须放在同一级目录下。</p>
<p>模代码结构</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">service.c client.c pipe.h Makefile</span><br><span class="line">$ cat Makefile</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:service client</span></span><br><span class="line"><span class="section">service:service.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">client:client.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f service client</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *pipe.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PIPE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PIPE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">"/tmp/pipe_withname"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#denif</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *service.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./pipe.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == mkfifo(PATHNAME, <span class="number">0644</span>))<span class="comment">//创建管道文件，文件权限为-rw-r--r--</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//若管道创建失败，则失败退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (fd = <span class="built_in">open</span>(PATHNAME, O_RDONLY)))<span class="comment">//只读打开管道文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//如果打开失败，则失败退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please wait...\n"</span>);</span><br><span class="line">        s = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(BUF_SIZE));</span><br><span class="line">        <span class="keyword">if</span>(s &lt;= <span class="number">0</span>)<span class="comment">//s小于0，则读取出现异常</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(buf, <span class="string">"quit\n"</span>))<span class="comment">//若client发送quit文本，则正常退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"quit signal, Bye...\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client said: %s"</span>, buf);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *client.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./pipe.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (fd = <span class="built_in">open</span>(PATHNAME, O_WRONLY)))<span class="comment">//只写打开管道文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//如打开失败，则失败退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client: "</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);<span class="comment">//从键盘获取字符串</span></span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//将获取到的字符串写进管道</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"quit\n"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="管道读写规则"><a href="#管道读写规则" class="headerlink" title="管道读写规则"></a>管道读写规则</h3><ul>
<li><p>当没有数据可读时：</p>
<ul>
<li>O_NONBLOCK disable：read调用阻塞，进程暂停执行，一直等到有数据来为止。</li>
<li>O_NONBLOCK enable：read返回-1，errno值为EAGAIN。</li>
</ul>
</li>
<li><p>当管道写满时：</p>
<ul>
<li>O_NONBLOCK disable：write调用阻塞，直到有进程读走数据。</li>
<li>O_NONBLOCK enable：write调用返回-1，errno值为EAGAIN。</li>
</ul>
</li>
<li><p>如果所有管道对应的写端文件描述符被关闭，则read返回0。</p>
</li>
<li><p>如果所有管道对应的读端文件描述符被关闭，则write操作会产生信号SIGPIPE，可能会导致write退出。</p>
</li>
<li><p>当要写入的数据不大于PIPE_BUF时，Linux保证写入数据的原子性。</p>
</li>
<li><p>当要写入的数据大于PIPE_BUF时，Linux不再保证写入数据的原子性。</p>
<hr>
</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><ul>
<li><strong>消息队列是操作系统内核提供的一个用于进程双方通信的队列（链表）</strong></li>
<li><strong>进程向消息队列中发送的数据块中包含一个特有的类型，类似于标签，用来表明该数据块来自哪个进程。</strong>（因为进程向消息队列中发送的数据块不能被自己拿走）</li>
<li><strong>消息队列每个消息的最大长度是有上限的（MSGMAX），每个消息队列的总的字节数是有上限的（MSGMNB），系统中消息队列的总数也是有上限的（MSGMNI）</strong>。</li>
<li><strong>消息队列的生命周期是随系统的</strong>。</li>
</ul>
<h3 id="IPC对象数据结构-usr-include-linux-ipc-h"><a href="#IPC对象数据结构-usr-include-linux-ipc-h" class="headerlink" title="IPC对象数据结构 /usr/include/linux/ipc.h"></a>IPC对象数据结构 /usr/include/linux/ipc.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span>&#123;</span></span><br><span class="line">    <span class="keyword">key_t</span>          _key; <span class="comment">/* Key supplied to xxxget(2) */</span></span><br><span class="line">    <span class="keyword">uid_t</span>           uid; <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>           gid; <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="keyword">uid_t</span> 		   cuid; <span class="comment">/* Effective UID of Creater */</span></span><br><span class="line">    <span class="keyword">gid_t</span>          cgid; <span class="comment">/* Effective GID of Creater */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short mode; <span class="comment">/* Permissions */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short _seq; <span class="comment">/* Sequeue number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>_key：用来判断两个进程看到的消息队列是否为同一个消息队列，每一个消息队列的_key值是唯一的</strong>。</li>
<li><strong>进行通信的两个进程获取消息队列_key值的方式必须是相同的</strong>。</li>
<li><strong>ipc资源的生命周期跟随内核的</strong>。<ul>
<li><strong>ipcs -q ：查看系统中现存的消息队列</strong></li>
<li><strong>ipcrm -q msgid ：删除消息队列</strong></li>
</ul>
</li>
</ul>
<h3 id="消息队列数据结构-usr-include-linux-msg-h"><a href="#消息队列数据结构-usr-include-linux-msg-h" class="headerlink" title="消息队列数据结构 /usr/include/linux/msg.h"></a>消息队列数据结构 /usr/include/linux/msg.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span> <span class="comment">/* first message on queue,unused */</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span> <span class="comment">/* last message in queue,unused */</span></span><br><span class="line"> 	<span class="keyword">__kernel_time_t</span> msg_stime; <span class="comment">/* last msgsnd time */</span></span><br><span class="line"> 	<span class="keyword">__kernel_time_t</span> msg_rtime; <span class="comment">/* last msgrcv time */</span></span><br><span class="line"> 	<span class="keyword">__kernel_time_t</span> msg_ctime; <span class="comment">/* last change time */</span></span><br><span class="line"> 	<span class="keyword">unsigned</span> <span class="keyword">long</span> msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line"> 	<span class="keyword">unsigned</span> <span class="keyword">long</span> msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line"> 	<span class="keyword">unsigned</span> short msg_cbytes; <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"> 	<span class="keyword">unsigned</span> short msg_qnum; <span class="comment">/* number of messages in queue */</span></span><br><span class="line"> 	<span class="keyword">unsigned</span> short msg_qbytes; <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"> 	<span class="keyword">__kernel_ipc_pid_t</span> msg_lspid; <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"> 	<span class="keyword">__kernel_ipc_pid_t</span> msg_lrpid; <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="消息队列中消息块的数据结构（自己定义）"><a href="#消息队列中消息块的数据结构（自己定义）" class="headerlink" title="消息队列中消息块的数据结构（自己定义）"></a>消息队列中消息块的数据结构（自己定义）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> mytype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>mtype：指明消息类型，它必须大于0，类似于标签，用来表明该数据块来自哪个进程</strong>。</li>
<li><strong>mtext[1]：存放消息数据，该数组的大小可以自行定义，但不能超过系统规定的上限值</strong>。</li>
</ul>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建/打开消息队列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>key：用来判断两个进程看到的消息队列是否为同一个消息队列，每一个消息队列的_key值是唯一的。<strong>通常该处调用key_t ftok()函数来设置唯一键值</strong>。</li>
<li>msgflg：<ul>
<li><strong>IPC_CREAT|IPC_EXEL：创建消息队列，如果想要创建的消息队列在底层已经存在，则出错返回；如果要创建的消息队列在底层不存在，则创建该消息队列，但不打开</strong>。</li>
<li><strong>IPC_CREAT：打开消息队列，如果想要打开的消息队列在底层已经存在，则打开该消息队列</strong>。</li>
</ul>
</li>
<li>返回值：<strong>成功返回消息队列的标识符；失败返回-1</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除消息队列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>msqid：<strong>消息队列标识符</strong>。</li>
<li>cmd：<strong>表示要对消息队列所做的操作</strong><ul>
<li><strong>IPC_RMID：立即删除消息队列</strong></li>
<li><strong>IPC_STAT：</strong></li>
</ul>
</li>
<li>buf：属性信息，若要删除消息队列，此处可以传递NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向消息队列发送数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>msqid：<strong>消息队列标识符</strong>。</li>
<li>msgp：<strong>是一个指针，指向准备发送的消息</strong>。</li>
<li>msgsz：<strong>是msgp指向的消息⻓度，这个⻓度不含保存消息类型的那个long int⻓整型</strong>。</li>
<li>msgflg：<strong>控制当队列存满或达到系统上限时要做的事情</strong><ul>
<li><strong>IPC_NOWAIT表示队列满不等待，返回EAGAIN错误</strong></li>
</ul>
</li>
<li>返回值：<strong>成功返回0；失败返回-1</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从消息队列取出数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>msgid：<strong>消息队列标识符</strong>。</li>
<li>msgp：<strong>是⼀个指针，指针指向准备接收的消息</strong>。</li>
<li>msgsz：<strong>是msgp指向的消息⻓度，这个⻓度不含保存消息类型的那个long int⻓整型</strong></li>
<li>msgtype：<strong>它可以实现接收优先级的简单形式</strong>。<ul>
<li><strong>msgtype=0返回队列第⼀条信息</strong></li>
<li><strong>msgtype&gt;0返回队列第⼀条类型等于msgtype的消息</strong></li>
<li><strong>msgtype&lt;0返回队列第⼀条类型⼩于等于msgtype绝对值的消息，并且是满⾜条件的消息类型最⼩的消息</strong></li>
</ul>
</li>
<li>msgflg：<strong>控制着队列中没有相应类型的消息可供接收时将要发⽣的事</strong><ul>
<li><strong>msgflg=IPC_NOWAIT，队列没有可读消息不等待，返回ENOMSG错误</strong></li>
<li><strong>msgflg=MSG_NOERROR，消息⼤⼩超过msgsz时被截断</strong></li>
<li><strong>msgtype&gt;0且msgflg=MSG_EXCEPT，接收类型不等于msgtype的第⼀条消息</strong></li>
</ul>
</li>
<li>返回值：<strong>成功返回实际放到接收缓冲区⾥去的字符个数，失败返回-1</strong></li>
</ul>
<h3 id="封装消息队列接口"><a href="#封装消息队列接口" class="headerlink" title="封装消息队列接口"></a>封装消息队列接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：1.接受消息时，如果消息队列里没有符合要求的消息，则会发生堵塞，直至消息队列中出现符和要求的消息后并读取它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MESSAGE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MESSAGE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">"."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRO_ID 0x6666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * type定义的值必须大于0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_TYPE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_TYPE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> type;</span><br><span class="line">  <span class="keyword">char</span> date[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatMsg</span><span class="params">()</span></span>;<span class="comment">//创建消息队列，成功返回消息队列msgid,失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestoryMsg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> msgid)</span></span>;<span class="comment">//删除消息队列，成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenMsg</span><span class="params">()</span></span>;<span class="comment">//打开消息队列，打开成功返回消息队列msgid,失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendMsg</span><span class="params">(<span class="keyword">int</span> msgid,<span class="keyword">long</span> who ,<span class="keyword">char</span>* msg)</span></span>;<span class="comment">//向消息队列发消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecMsg</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">long</span> who,<span class="keyword">char</span> msg[])</span></span>;<span class="comment">//从消息队列接受消息，成功返回0，并将消息写入msg，失败返回-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//message.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./message.h"</span><span class="comment">//使用时需确保头文件与message.c文件在同一级目录下</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatMsg</span><span class="params">()</span><span class="comment">//创建消息队列,成功返回消息队列msgid,失败返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  umask(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> msgget(ftok(PATHNAME, PRO_ID),IPC_CREAT | IPC_SET | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenMsg</span><span class="params">()</span><span class="comment">//打开消息队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> msgget(ftok(PATHNAME, PRO_ID),IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendMsg</span><span class="params">(<span class="keyword">int</span> msgid,<span class="keyword">long</span> who ,<span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">buf</span>;</span></span><br><span class="line">  buf.type = who;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf.date, msg);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span> &gt; msgsnd(msgid, (<span class="keyword">void</span>*)&amp;buf,<span class="keyword">sizeof</span>(buf.date),<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecMsg</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">long</span> who, <span class="keyword">char</span>  msg[])</span><span class="comment">//从消息队列接受消息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">buf</span>;</span></span><br><span class="line">  buf.type = who;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please wait...\n"</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> == msgrcv(msgid, (<span class="keyword">void</span>*)&amp;buf, <span class="keyword">sizeof</span>(buf.date), buf.type,<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(msg, buf.date);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestoryMsg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> msgid)</span><span class="comment">//删除消息队列，成功返回0，失败返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过封装好的消息队列接口实现client-amp-service互相通信"><a href="#通过封装好的消息队列接口实现client-amp-service互相通信" class="headerlink" title="通过封装好的消息队列接口实现client&amp;service互相通信"></a>通过封装好的消息队列接口实现client&amp;service互相通信</h4><ul>
<li><p><strong>service.c &amp; client.c 需要和头文件在同一级目录下</strong></p>
<p>目录结构</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">service.c client.c message.c message.h Makefile</span><br><span class="line">$ cat Makefile</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:service client</span></span><br><span class="line"><span class="section">service:service.c message.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">client:client.c message.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f service client</span><br></pre></td></tr></table></figure>


</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./message.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> msgid;</span><br><span class="line">  <span class="keyword">char</span> rec_msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> msg[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> != (msgid = CreatMsg()))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CreatMsg success...\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> != (msgid = OpenMsg()))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"OpenMsg success...\n"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    RecMsg(msgid, CLIENT_TYPE, rec_msg);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(rec_msg, <span class="string">"quit\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"quit signal,Bye...\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client$ %s"</span>,rec_msg);</span><br><span class="line">    <span class="built_in">memset</span>(rec_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(rec_msg));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"service# "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    fgets(msg, <span class="keyword">sizeof</span>(msg), <span class="built_in">stdin</span>);</span><br><span class="line">    SendMsg(msgid, SERVICE_TYPE, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DestoryMsg(msgid);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./message.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> msgid;</span><br><span class="line">  <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> rec_msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> != (msgid = OpenMsg()))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"OpenMsg success...\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client# "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    fgets(msg, <span class="keyword">sizeof</span>(msg), <span class="built_in">stdin</span>);</span><br><span class="line">    SendMsg(msgid, CLIENT_TYPE, msg);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(msg, <span class="string">"quit\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Bye...\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RecMsg(msgid, SERVICE_TYPE, rec_msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"service# %s"</span>, rec_msg);</span><br><span class="line">    <span class="built_in">memset</span>(rec_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(rec_msg));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul>
<li><strong>共享内存的本质是不同的进程看到同一块物理内存</strong>。共享内存就是先在物理内存上开辟一段空间，再通过进程的页表映射进进程的虚拟内存空间。</li>
<li><strong>共享内存同时映射进两个进程的虚拟内存空间，他们各自在虚拟内存空间上的地址可能不相同，但是他们的确会指向同一块物理内存</strong>。</li>
<li><strong>共享内存是进程间通信最快的方式</strong>。</li>
<li><strong>共享内存的生命周期跟随内核</strong>。<ul>
<li>ipcs -m：可以查看目前系统中存在的共享内存</li>
<li>ipcrm -m shmid：删除共享内存（通过shmid指定）</li>
</ul>
</li>
<li><strong>共享内存没有提供互斥与同步机制，需要自己手动维护</strong>。</li>
</ul>
<h3 id="共享内存数据结构"><a href="#共享内存数据结构" class="headerlink" title="共享内存数据结构"></a>共享内存数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* operation perms */</span></span><br><span class="line"> <span class="keyword">int</span> shm_segsz; <span class="comment">/* size of segment (bytes) */</span></span><br><span class="line"> <span class="keyword">__kernel_time_t</span> shm_atime; <span class="comment">/* last attach time */</span></span><br><span class="line"> <span class="keyword">__kernel_time_t</span> shm_dtime; <span class="comment">/* last detach time */</span></span><br><span class="line"> <span class="keyword">__kernel_time_t</span> shm_ctime; <span class="comment">/* last change time */</span></span><br><span class="line"> <span class="keyword">__kernel_ipc_pid_t</span> shm_cpid; <span class="comment">/* pid of creator */</span></span><br><span class="line"> <span class="keyword">__kernel_ipc_pid_t</span> shm_lpid; <span class="comment">/* pid of last operator */</span></span><br><span class="line"> <span class="keyword">unsigned</span> short shm_nattch; <span class="comment">/* no. of current attaches */</span></span><br><span class="line"> <span class="keyword">unsigned</span> short shm_unused; <span class="comment">/* compatibility */</span></span><br><span class="line"> <span class="keyword">void</span> *shm_unused2; <span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line"> <span class="keyword">void</span> *shm_unused3; <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出，共享内存也为IPC资源。</li>
</ul>
<h3 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key：共享内存段的名字</strong>。</li>
<li><strong>size：所想要申请的共享内存的空间大小</strong><ul>
<li><strong>一般必须为页（1页=4KB）的整数倍</strong></li>
<li><strong>如果此处size = 4097（字节），那么操作系统会分配2页（4096 * 2字节）的空间用于该共享内存，但是用户只可以使用4097字节的空间大小，这样就会造成空间的浪费</strong>。</li>
</ul>
</li>
<li><strong>shmflg：由九个权限标志构成，用法与创建文件时使用的mode模式标志是一样的</strong></li>
<li><strong>返回值：成功返回共享内存标识码（shmid）；失败返回-1</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将创建好的共享内存传递给进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span>* shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>shmid：共享内存的标识码（即为shmget成功返回值）</strong>。</li>
<li><strong>shmaddr：指定连接的地址，即指定该进程虚拟内存中的shmaddr地址与实际物理内存中的共享内存连接</strong><ul>
<li><strong>shmaddr为NULL时，内核自动分配地址</strong></li>
<li><strong>shmaddr不为NULL时：</strong><ul>
<li><strong>shmflg无SHM_RND标记，则以shmaddr为连接地址</strong></li>
<li><strong>shmflg有SHM_RND标记，则连接地址会自动向下调整为SHMLBA的整数倍；公式：shmaddr-(shmaddr%SHNLBA)</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>shmflg：两个可能取值为SHM_RND和SHM_RDONLY</strong><ul>
<li><strong>shmflg = SHM_RDONLY表示连接操作用来只读共享内存</strong></li>
</ul>
</li>
<li><strong>返回值：成功返回一个指针，指向共享内存；失败返回-1</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将共享内存与当前进程脱离，不会删除共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span>* shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>shmaddr：指向共享内存的指针</strong></li>
<li><strong>返回值：成功返回0；失败返回-1</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>shmid：共享内存标识码</strong></li>
<li><strong>cmd：表示要对共享内存做的操作（有3个可取值）</strong><ul>
<li><strong>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值</strong></li>
<li><strong>IPC_SET：在进程有足够权限的前提下，把共享内存的当前关联值设置为shmid_ds数据结构中给出的值</strong></li>
<li><strong>IPC_RMID：删除共享内存段</strong></li>
</ul>
</li>
</ul>
<h4 id="封装共享内存接口"><a href="#封装共享内存接口" class="headerlink" title="封装共享内存接口"></a>封装共享内存接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_mem.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 封装共享内存接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SHARED_MEM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SHARED_MEM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">"."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRO_ID 0x6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatShm</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestoryShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkShm</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CutShm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_mem.c</span></span><br><span class="line"><span class="comment">//确保头文件shared_mem.h与该文件在同一级目录下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./shared_mem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatShm</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  umask(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> shmget(ftok(PATHNAME, PRO_ID), <span class="built_in">size</span>, IPC_CREAT | IPC_EXCL | <span class="number">0644</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestoryShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetShm</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shmget(ftok(PATHNAME, PRO_ID), <span class="built_in">size</span>, IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">LinkShm</span><span class="params">(<span class="keyword">int</span> shmid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CutShm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shmdt(shmaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用封装好的接口来验证共享内存"><a href="#使用封装好的接口来验证共享内存" class="headerlink" title="使用封装好的接口来验证共享内存"></a>使用封装好的接口来验证共享内存</h4><ul>
<li><p>运行时service进程先运行，client后运行</p>
<p>目录结构</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">service.c client.c shared_mem.c shared_mem.h Makefile</span><br><span class="line">$ cat Makefile</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:service client</span></span><br><span class="line"><span class="section">service:service.c shared_mem.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">client:client.c shared_mem.c</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f service client</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *service.c</span></span><br><span class="line"><span class="comment"> *该进程用来控制共享内存的创建和销毁</span></span><br><span class="line"><span class="comment"> *该进程运行期间，以字符串的方式读取共享内存上的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./shared_mem.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shmid;</span><br><span class="line">  <span class="keyword">char</span>* shmp;</span><br><span class="line">  shmid = CreatShm(<span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, shmid);<span class="comment">//打印共享内存在该进程的虚拟内存空间上的地址</span></span><br><span class="line">  shmp = LinkShm(shmid);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> == (<span class="keyword">int</span>)shmp)</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(shmp, <span class="string">"quit\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"quit Bye...\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client# %s"</span>, shmp);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"> CutShm(shmp);</span><br><span class="line"> DestoryShm(shmid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *client.c</span></span><br><span class="line"><span class="comment"> *该进程不控制共享内存的创建与销毁，只对共享内存中的内容进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./shared_mem.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shmid;</span><br><span class="line">  <span class="keyword">char</span>* shmp;</span><br><span class="line">  shmid = GetShm(<span class="number">1024</span>);</span><br><span class="line">  shmp = LinkShm(shmid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, shmp);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> == (<span class="keyword">int</span>)shmp)</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client: "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fgets(shmp, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(shmp, <span class="string">"quit\n"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Bye...\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CutShm(shmp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><ul>
<li><strong>信号量集指信号量的集合，也就是由多个信号量组成的数组，可以同时控制多种资源的分配问题</strong>。</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li><p><strong>信号量：本质上是一个计数器</strong>。</p>
</li>
<li><p><strong>信号量本身也是临界资源。信号量的++（V操作；释放操作）/–（P操作；申请操作）操作一定是原子的</strong>。</p>
</li>
<li><p><strong>共享资源必须是互斥的，这样才能保证共享资源的原子性</strong>。</p>
</li>
<li><p><strong>两个进程看到的一份公共资源我们称之为临界资源，把各个进程中访问临界资源的代码叫做临界区</strong>。</p>
</li>
<li><p><strong>互斥：在临界区当中，通过进程临界区访问临界资源时，任何时候只能有一个进程访问临界资源</strong>。</p>
</li>
<li><p><strong>同步：在互斥的基础之上，让访问具有一定的顺序</strong>。</p>
</li>
<li><p><strong>原子性：一件事情只有两种状态</strong>。</p>
</li>
</ul>
<h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><ul>
<li><strong>互斥即就是当一个进程在访问一个共享资源时，其他的进程就不可以访问该共享资源，也就是说任意时刻，只有一个进程可以访问该共享资源</strong>。</li>
</ul>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><ul>
<li><strong>进程同步代表多个进程要相互合作完成同一个任务时，通常会有多个进程访问同一份资源，也就是在互斥的基础上，让访问具有一定顺序</strong>。</li>
</ul>
<h4 id="信号量结构体伪代码"><a href="#信号量结构体伪代码" class="headerlink" title="信号量结构体伪代码"></a>信号量结构体伪代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    pointer_PCB <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//信号量本质上是一个计数器</span></span><br></pre></td></tr></table></figure>

<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(s)</span><br><span class="line">&#123;</span><br><span class="line">    s.value = s.value - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将该进程的状态设置为等待状态</span></span><br><span class="line">        <span class="comment">//2.将该进程的PCB插入相应的等待状态中的PCB队列的队尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">V(s)</span><br><span class="line">&#123;</span><br><span class="line">    s.value = s.value + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.唤醒相应的等待状态PCB队列中的一个进程</span></span><br><span class="line">        <span class="comment">//2.将该进程的状态改变为就绪态</span></span><br><span class="line">        <span class="comment">//3.将该进程插入就绪状态PCB队列的队尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量集结构体"><a href="#信号量集结构体" class="headerlink" title="信号量集结构体"></a>信号量集结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="keyword">time_t</span>         sem_otime; <span class="comment">/* Last semop time */</span></span><br><span class="line">    <span class="keyword">time_t</span>         sem_ctime; <span class="comment">/*Last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sem_nsems; <span class="comment">/* No. of semaphores in set */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来创建和访问一个信号量集</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key：信号量集的名字</strong></li>
<li><strong>nsems：信号集中包含信号量的个数</strong></li>
<li><strong>semflg：由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的</strong></li>
<li><strong>返回值：成功返回信号量集的标识码（非负整数；semid）;失败返回-1</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来控制信号量集</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>semid：信号量集标识码</strong></p>
</li>
<li><p><strong>semnum：信号集中信号量的序号</strong></p>
</li>
<li><p><strong>cmd：要执行的操作</strong></p>
<ul>
<li><p><strong>SETVAL：设置信号量集中的信号量计数值</strong></p>
<ul>
<li><pre><code class="c"><span class="keyword">union</span> semun
{
  <span class="keyword">int</span>              val; <span class="comment">/* Value for SETVAL */</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span>
  <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;<span class="comment">/* Array for GETALL, SETALL */</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span><span class="comment">/* Buffer for IPC_INFO (Linux-specific) */</span>
};
&lt;!--￼<span class="number">35</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>semid：要访问的信号量集的标识码</strong></p>
</li>
<li><p><strong>sops：是一个指针，指向一个结构体，该结构体操作系统已经定义</strong></p>
<ul>
<li><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span>
<span class="class">{</span>
    short sem_num;
    short sem_op;
    short sem_flg;
};
<span class="comment">//sem_num：信号量的编号</span>
<span class="comment">//sem_op：是信号量一次PV操作时加减的数值，一般会用到两个值：</span>
<span class="comment">//          一个是‘-1’，也就是P操作，等待信号量变得可用；</span>
<span class="comment">//          另一个是‘+1’，也就是V操作，发出信号量已经变得可用；</span>
<span class="comment">//sem_flg：有两个取值，分别为IPC_NOWAIT和IPC_UNDO</span>
&lt;!--￼<span class="number">36</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my_sem.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 封装二元信号量集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_SEM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_SEM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为ftok函数定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">"."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRO_ID 0x6666</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> semnu</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> * <span class="title">buf</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> short *<span class="built_in">array</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatSem</span><span class="params">(<span class="keyword">int</span> nums)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CommSem</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> semflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitSem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> nums, <span class="keyword">int</span> initval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSem</span><span class="params">(<span class="keyword">int</span> nums)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestorySem</span><span class="params">(<span class="keyword">int</span> semid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PVcomm</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> who, <span class="keyword">int</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> semid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> semid)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my_sem.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./my_sem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CommSem</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> semflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">key_t</span> key = ftok(PATHNAME, PRO_ID);</span><br><span class="line">  <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> semget(key, nums, semflg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreatSem</span><span class="params">(<span class="keyword">int</span> nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommSem(nums, IPC_CREAT|IPC_EXCL|<span class="number">0644</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到已创建的信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSem</span><span class="params">(<span class="keyword">int</span> nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommSem(nums, IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PVcomm</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> who, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> _<span class="title">sembuf</span>;</span></span><br><span class="line">  _sembuf.sem_num = who;</span><br><span class="line">  _sembuf.sem_op = op;</span><br><span class="line">  _sembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> semop(semid, &amp;_sembuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量集进行P操作，该处即为给信号量的计数值-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PVcomm(semid, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量进行V操作，该处即为给信号量的计数值+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PVcomm(semid, <span class="number">0</span>, +<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestorySem</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量集，二元信号量集初始信号量计数值应该初始化为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitSem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> nums, <span class="keyword">int</span> initval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">union</span> semnu _semnu;</span><br><span class="line">  _semnu.val = initval;</span><br><span class="line">  <span class="keyword">return</span> semctl(semid, nums, SETVAL, _semnu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c（不添加二元信号量）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./my_sem.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//int semid = CreatSem(1);//创建包含一个信号量的信号集</span></span><br><span class="line">  <span class="comment">//InitSem(semid, 0, 1);//初始化所创建的信号集,这里用1初始化是因为第一次使用信号量时，他所对应的对象应该是可以访问的</span></span><br><span class="line">  <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> == id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//P(semid);//子进程对信号量集进行P操作</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"A"</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">12345</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"A "</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">12378</span>);</span><br><span class="line">      <span class="comment">//V(semid);//子进程对信号量集合进行V操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//P(semid);//父进程对信号量集进行P操作</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">13456</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"B "</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">13487</span>);</span><br><span class="line">      <span class="comment">//V(semid);//父进程对信号量集进行V操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(wait(<span class="literal">NULL</span>) != id);<span class="comment">//等待子进程退出</span></span><br><span class="line">    DestorySem(semid);<span class="comment">//销毁信号量集</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：<a href="https://imgchr.com/i/iomOaT" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2018/11/05/iomOaT.png" alt="iomOaT.png"></a></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加二元信号量</span></span><br><span class="line"><span class="comment">//因为这里的显示器即为子进程与父进程的共享资源，所以我们使用二元信号量，当子进程使用显示器进行P操作时，父进程就必须等待子进程进行V操作之后才可以向下执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./my_sem.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semid = CreatSem(<span class="number">1</span>);<span class="comment">//创建包含一个信号量的信号集</span></span><br><span class="line">  InitSem(semid, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//初始化所创建的信号集,这里用1初始化是因为第一次使用信号量时，他所对应的对象应该是可以访问的</span></span><br><span class="line">  <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> == id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">      P(semid);<span class="comment">//子进程对信号量集进行P操作</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"A"</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">12345</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"A "</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">12378</span>);</span><br><span class="line">      V(semid);<span class="comment">//子进程对信号量集合进行V操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">      P(semid);<span class="comment">//父进程对信号量集进行P操作</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">13456</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"B "</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      usleep(<span class="number">13487</span>);</span><br><span class="line">      V(semid);<span class="comment">//父进程对信号量集进行V操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(wait(<span class="literal">NULL</span>) != id);<span class="comment">//等待子进程退出</span></span><br><span class="line">    DestorySem(semid);<span class="comment">//销毁信号量集</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果：<a href="https://imgchr.com/i/ionFZ6" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2018/11/05/ionFZ6.png" alt="ionFZ6.png"></a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AHAOAHA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="http://ahaoaha.top/2018/10/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">http://ahaoaha.top/2018/10/31/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="http://ahaoaha.top" target="_blank">苦心人，天不負，臥薪嘗膽，三千越甲可吞吳</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/11/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">单例模式</div></div></a></div><div class="next-post pull-right"><a href="/2018/10/22/Linux%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux下的文件操作</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相關推薦</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/03/19/IP协议/" title="IP协议"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-19</div><div class="relatedPosts_title">IP协议</div></div></a></div><div class="relatedPosts_item"><a href="/2018/12/03/Linux中的线程/" title="Linux中的线程"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-03</div><div class="relatedPosts_title">Linux中的线程</div></div></a></div><div class="relatedPosts_item"><a href="/2019/03/19/UDP协议/" title="UDP协议"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-19</div><div class="relatedPosts_title">UDP协议</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/26/进程间的状态切换/" title="进程间的状态切换"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-26</div><div class="relatedPosts_title">进程间的状态切换</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/08/Linux下的进程/" title="Linux下的进程"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-08</div><div class="relatedPosts_title">Linux下的进程</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/22/Linux下的文件操作/" title="Linux下的文件操作"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="relatedPosts_title">Linux下的文件操作</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By AHAOAHA</div><div class="framework-info"><span>Power by </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字型"><i class="fas fa-plus"></i></button><button id="font_minus" title="縮小字型"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="簡繁轉換">繁</button><button id="darkmode" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="設定"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到頂部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>